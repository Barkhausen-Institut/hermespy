# -*- coding: utf-8 -*-
"""Chirp Frequency Shift Keying Waveform Generator."""

from __future__ import annotations
from typing import Optional
from typing import Tuple, Type
from ruamel.yaml import SafeConstructor, SafeRepresenter, Node
import numpy as np
from scipy import integrate
from scipy import constants
from modem import Modem
from modem.waveform_generator import WaveformGenerator
from modem.waveform_generator_chirp_fsk import WaveformGeneratorChirpFsk
from simulator_core.modem_output_patterns.radar_output import RadarOutput


class WaveformGeneratorChirpFskRadar(WaveformGeneratorChirpFsk):
    """ Implements a chirp (FMCW) FSK waveform generator with radar detection.

    The waveform is the same generated by WaveformGeneratorChirpFsk, but the receiver is a radar detector instead of
    a communications detector.

    The radar detector produces a range(delay)-Doppler response to be post-processed outside this class.

    Currently the following radar detection algorithms:
    - range detection using matched filter with preamble chirps, coherent integration

    """

    # YAML tag
    yaml_tag = WaveformGeneratorChirpFsk.yaml_tag + "Radar"

    _range_bins: np.ndarray
    _doppler_bins: np.ndarray

    def __init__(self,
                 modem: Modem,
                 chirp_duration: float,
                 chirp_bandwidth: float,
                 num_data_chirps: int,
                 modulation_order: int,
                 freq_difference: Optional[float] = None,
                 oversampling_factor: Optional[float] = None,
                 num_pilot_chirps: Optional[int] = None,
                 guard_interval: Optional[float] = None,
                 pulse_repetition_interval: Optional[float] = None) -> None:
        """Object initialization.

        Args:
            modem(Modem): the Modem object using this waveform
            chirp_duration(float): in [s]
            chirp_bandwidth(float): in [Hz]
            num_data_chirps(int): number of modulated chirps containing data
            modulation_order(int, optional): size of modulation constellation (default = 2)
            freq_difference(float, optional): difference between adjacent modulation frequencies
                                              (default = chirp_bandwidth / modulation_order)
            num_pilot_chirps(int, optional): number of unmodulated chirps at beginning of frame (default = 0)
            guard_interval(float, optional): guard interval [s] between consecutive frames
            pulse_repetition_interval(float, optional): interval between consecutive chirps [s]
                                                        (default = chirp_duration)
        """

        WaveformGeneratorChirpFsk.__init__(self,
                                           modem=modem,
                                           chirp_duration=chirp_duration,
                                           chirp_bandwidth=chirp_bandwidth,
                                           num_data_chirps=num_data_chirps,
                                           modulation_order=modulation_order,
                                           freq_difference=freq_difference,
                                           oversampling_factor=oversampling_factor,
                                           num_pilot_chirps=num_pilot_chirps,
                                           guard_interval=guard_interval,
                                           pulse_repetition_interval=pulse_repetition_interval
                                           )

        delay_bins = (.5 + np.arange(self.samples_in_chirp)) / self.sampling_rate
        self._range_bins = delay_bins * constants.speed_of_light / 2
        self._doppler_bins = np.array([0])

    def receive_frame(self,
                      rx_signal: np.ndarray,
                      timestamp_in_samples: int,
                      noise_var: float) -> Tuple[RadarOutput, np.ndarray]:

        useful_signal_length = self.samples_in_frame

        # Received signal is too short to recover a full frame
        if rx_signal.shape[1] < useful_signal_length:
            rx_signal = np.array([])
            radar_output = RadarOutput()
        else:

            frame_signal = rx_signal[0, :useful_signal_length]

            # remove data symbols
            # frame_signal = frame_signal[:self.samples_in_pulse_interval * self.num_pilot_chirps]

            matched_filter = self._matched_filter()
            frame_signal = np.convolve(frame_signal, matched_filter)
            frame_signal = np.delete(frame_signal, slice(matched_filter.size - 1))
            frame_signal = frame_signal[self._get_non_zero_idxs(symbol_type='pilot')]

            fast_time = frame_signal.reshape((self.num_pilot_chirps, self.samples_in_chirp))

            # coherent integration
            fast_time = np.abs(np.sum(fast_time, axis=0)[:, np.newaxis])

            radar_output = RadarOutput(range_bins=self._range_bins, doppler_bins=self._doppler_bins,
                                       range_doppler_response=fast_time)

        return radar_output, rx_signal

    def _matched_filter(self) -> np.array:

        initial_frequency = -.5 * self.chirp_bandwidth
        frequency, amplitude = self._calculate_chirp_frequencies(np.array([initial_frequency]))

        phase = 2 * np.pi * integrate.cumtrapz(frequency, dx=1 / self.sampling_rate, initial=0)
        chirp = amplitude * np.exp(1j * phase)

        matched_filter = np.conj(np.flip(chirp))

        return matched_filter

    @classmethod
    def to_yaml(cls: Type[WaveformGeneratorChirpFsk],
                representer: SafeRepresenter,
                node: WaveformGeneratorChirpFsk) -> Node:
        """Serialize an `WaveformGeneratorChirpFsk` object to YAML.

        Args:
            representer (SafeRepresenter):
                A handle to a representer used to generate valid YAML code.
                The representer gets passed down the serialization tree to each node.

            node (WaveformGeneratorChirpFsk):
                The `WaveformGeneratorChirpFsk` instance to be serialized.

        Returns:
            Node:
                The serialized YAML node
        """

        state = {
            "chirp_duration": node.chirp_duration,
            "chirp_bandwidth": node.chirp_bandwidth,
            "freq_difference": node.freq_difference,
            "num_pilot_chirps": node.num_pilot_chirps,
            "num_data_chirps": node.num_data_chirps,
            "guard_interval": node.guard_interval,
        }

        mapping = representer.represent_mapping(cls.yaml_tag, state)
        mapping.value.extend(WaveformGenerator.to_yaml(representer, node).value)

        return mapping

    @classmethod
    def from_yaml(cls: Type[WaveformGeneratorChirpFsk], constructor: SafeConstructor, node: Node)\
            -> WaveformGeneratorChirpFsk:
        """Recall a new `WaveformGeneratorChirpFsk` instance from YAML.

        Args:
            constructor (SafeConstructor):
                A handle to the constructor extracting the YAML information.

            node (Node):
                YAML node representing the `WaveformGeneratorChirpFsk` serialization.

        Returns:
            WaveformGenerator:
                Newly created `WaveformGeneratorChirpFsk` instance.
        """

        state = constructor.construct_mapping(node)
        return cls(**state)

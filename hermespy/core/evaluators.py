# -*- coding: utf-8 -*-

from __future__ import annotations
from collections.abc import Sequence
from typing_extensions import override

import matplotlib.pyplot as plt
import numpy as np

from .antennas import AntennaMode
from .device import (
    Device,
    DeviceOutput,
    OperationResult,
    ProcessedDeviceInput,
    Receiver,
    Reception,
    Transmitter,
    Transmission,
)
from .hooks import Hook
from .logarithmic import ValueType
from .pymonte import (
    Artifact,
    Evaluation,
    EvaluationResult,
    Evaluator,
    ScalarEvaluationResult,
    ScalarEvaluator,
    GridDimensionInfo,
)
from .signal_model import Signal
from .visualize import PlotVisualization, StemVisualization, VAT

__author__ = "Jan Adler"
__copyright__ = "Copyright 2024, Barkhausen Institut gGmbH"
__credits__ = ["Jan Adler"]
__license__ = "AGPLv3"
__version__ = "1.5.0"
__maintainer__ = "Jan Adler"
__email__ = "jan.adler@barkhauseninstitut.org"
__status__ = "Prototype"


class PowerArtifact(Artifact):
    """The artifact of a received power evaluation.

    Generated by the :meth:`artifact<hermespy.core.evaluators.PowerEvaluation.artifact>` of :class:`PowerEvaluation<hermespy.core.evaluators.PowerEvaluation>`.
    """

    __power: np.ndarray

    def __init__(self, power: np.ndarray) -> None:
        """
        Args:

            power: The received power in Watts for each antenna stream.
        """

        # Initialize the base class
        Artifact.__init__(self)

        # Initialize class members
        self.__power = power

    @property
    def power(self) -> np.ndarray:
        """The received power in Watts for each antenna stream."""

        return self.__power

    @override
    def __str__(self) -> str:
        power_db = 10 * np.log10(np.sum(self.__power))
        return f"{power_db:.2} dB"

    @override
    def to_scalar(self) -> float:
        return float(np.sum(self.__power))


class PowerEvaluation(Evaluation[StemVisualization]):
    """The evaluation of a received power evaluation.

    Generated by evaluating power evaluators.
    """

    __power: np.ndarray

    def __init__(self, power: np.ndarray) -> None:
        """
        Args:

            power: The received power in Watts for each antenna stream.
        """

        # Initialize the base class
        super().__init__()

        # Initialize class members
        self.__power = power

    @property
    def power(self) -> np.ndarray:
        """The received power indicator in V^2 for each antenna stream."""

        return self.__power

    @override
    def artifact(self) -> PowerArtifact:
        return PowerArtifact(self.__power)

    @property
    @override
    def title(self) -> str:
        return "Received Power"

    @override
    def _prepare_visualization(
        self, figure: plt.Figure | None, axes: VAT, **kwargs
    ) -> StemVisualization:
        ax: plt.Axes = axes.flat[0]
        ax.set_xlabel("Antenna Stream")
        ax.set_ylabel("Power [W]")

        container = ax.stem(np.zeros_like(self.__power))
        return StemVisualization(figure, axes, container)

    @override
    def _update_visualization(self, visualization: StemVisualization, **kwargs) -> None:
        visualization.container.markerline.set_ydata(self.__power)


class ReceivePowerEvaluator(ScalarEvaluator):
    """Estimates the signal power received receivers."""

    __receive_hook: Hook[Reception]
    __reception: Reception | None

    def __init__(
        self,
        target: Receiver,
        confidence: float = 1.0,
        tolerance: float = 0.0,
        min_num_samples: int = 1024,
        plot_scale: str = "linear",
        tick_format: ValueType = ValueType.LIN,
        plot_surface: bool = True,
    ) -> None:
        """
        Args:
            target: The device or receiver to measure the received power of.
            accuracy: Acceptable bound around the mean value of the estimated scalar performance indicator.
            tolerance: Required confidence level for the given `accuracy`.
            min_num_samples: Minimum number of samples required to compute the confidence bound.
            plot_surface:
                Enable surface plotting for two-dimensional grids.
                Enabled by default.
            base_dimension_index: Index of the base dimension used for plotting.
        """

        # Initialize the base class
        ScalarEvaluator.__init__(
            self, confidence, tolerance, min_num_samples, plot_scale, tick_format, plot_surface
        )

        # Initialize class members
        self.__receive_hook = target.add_receive_callback(self.__receive_callback)
        self.__reception = None
        self.plot_scale = plot_scale

    def __receive_callback(self, reception: Reception) -> None:
        """Callback function notifying the evaluator of a new reception."""

        self.__reception = reception

    @override
    def evaluate(self) -> PowerEvaluation:
        if self.__reception is None:
            raise RuntimeError(
                "Power evaluator could not fetch reception. Has the receiver received data?"
            )

        power = self.__reception.signal.power
        return PowerEvaluation(power)

    @property
    @override
    def abbreviation(self) -> str:
        return "RxPwr"

    @property
    @override
    def title(self) -> str:
        return "Receive Power"

    def __del__(self) -> None:
        self.__receive_hook.remove()


class TransmitPowerEvaluator(ScalarEvaluator):
    """Estimates the signal power transmitted by transmitters."""

    __transmit_hook: Hook[Transmission]
    __transmission: Transmission | None

    def __init__(
        self,
        target: Transmitter,
        confidence: float = 1.0,
        tolerance: float = 0.0,
        min_num_samples: int = 1024,
        plot_scale: str = "linear",
        tick_format: ValueType = ValueType.LIN,
        plot_surface: bool = True,
    ) -> None:
        """
        Args:
            target: The device or transmitter to measure the received power of.
            confidence: Required confidence level for the given `tolerance` between zero and one.
            tolerance: Acceptable non-negative bound around the mean value of the estimated scalar performance indicator.
            min_num_samples: Minimum number of samples required to compute the confidence bound.
            plot_scale: Scale of the plot. Can be ``'linear'`` or ``'log'``.
            tick_format: Tick format of the plot.
            plot_surface: Enable surface plotting for two-dimensional grids. Enabled by default.
        """

        # Initialize the base class
        ScalarEvaluator.__init__(
            self, confidence, tolerance, min_num_samples, plot_scale, tick_format, plot_surface
        )

        # Initialize class members
        self.__transmit_hook = target.add_transmit_callback(self.__transmit_callback)
        self.__transmission = None
        self.plot_scale = plot_scale

    def __transmit_callback(self, transmission: Transmission) -> None:
        """Callback function notifying the evaluator of a new transmission."""

        self.__transmission = transmission

    @override
    def evaluate(self) -> PowerEvaluation:
        if self.__transmission is None:
            raise RuntimeError(
                "Power evaluator could not fetch transmission. Has the transmitter transmitted data?"
            )

        return PowerEvaluation(self.__transmission.signal.power)

    @property
    @override
    def abbreviation(self) -> str:
        return "TxPwr"

    @property
    @override
    def title(self) -> str:
        return "Transmit Power"

    def __del__(self) -> None:
        self.__transmit_hook.remove()


class PAPRArtifact(Artifact):
    """Artifact of a peak-to-average power ratio evaluation."""

    __papr: float

    def __init__(self, stream_papars: np.ndarray) -> None:
        """
        Args:

            stream_papars: PAPRs of each antenna stream.
        """

        # Initialize the base class
        Artifact.__init__(self)

        # Initialize class members
        self.__papr = float(np.mean(stream_papars, keepdims=False))

    @override
    def __str__(self) -> str:
        power_db = 10 * np.log10(self.__papr)
        return f"{power_db:.2} dB"

    @override
    def to_scalar(self) -> float:
        return self.__papr


class PAPREvaluation(Evaluation[PlotVisualization]):
    """Peak-to-average power ratio (*PAPR*) evaluation."""

    __instantaneous_power: np.ndarray

    def __init__(self, instantaneous_power: np.ndarray) -> None:
        """
        Args:

            instantaneous_power: The instantaneous power in :math:`V^2` for each antenna stream.
        """

        # Initialize the base class
        super().__init__()

        # Initialize class members
        self.__instantaneous_power = instantaneous_power

    @property
    def instantaneous_power(self) -> np.ndarray:
        """The instantaneous power in :math:`V^2` for each antenna stream."""

        return self.__instantaneous_power

    @override
    def artifact(self) -> PAPRArtifact:
        # Peak-to-average power ratio per stream
        average_power = np.mean(self.instantaneous_power, axis=1, keepdims=False)
        peak_power = np.max(self.instantaneous_power, axis=1, keepdims=False)
        stream_paprs = peak_power / average_power

        return PAPRArtifact(stream_paprs)

    @property
    @override
    def title(self) -> str:
        return "Instantaneous Power"

    @override
    def _prepare_visualization(
        self, figure: plt.Figure | None, axes: VAT, **kwargs
    ) -> PlotVisualization:
        ax: plt.Axes = axes.flat[0]
        ax.set_xlabel("Sample Index")
        ax.set_ylabel("Power [V^2]")

        lines = np.empty_like(axes, dtype=object)
        lines.flat[0] = []
        zeros = np.zeros(self.__instantaneous_power.shape[1], dtype=np.float64)
        indices = np.arange(self.__instantaneous_power.shape[1])
        for s in range(self.__instantaneous_power.shape[0]):
            lines.flat[0].append(ax.plot(indices, zeros, label=f"Stream #{s}")[0])

        ax.legend()

        return PlotVisualization(figure, axes, lines)

    @override
    def _update_visualization(self, visualization: PlotVisualization, **kwargs) -> None:
        # Update the y-data of each line in the plot
        for line, power in zip(visualization.lines.flat[0], self.__instantaneous_power):
            line.set_ydata(power)

        visualization.axes[0, 0].relim()
        visualization.axes[0, 0].autoscale_view(True, True, True)


class PAPR(ScalarEvaluator):
    """Peak-to-average power ratio (*PAPR*) evaluator.

    Computes the average *PAPR* of radio-frequency band signals transmitted and received by devices during evaluation runtime.
    """

    __direction: AntennaMode
    __output_hook: Hook[DeviceOutput] | None
    __input_hook: Hook[ProcessedDeviceInput] | None
    __output: DeviceOutput | None
    __input: ProcessedDeviceInput | None

    def __init__(
        self,
        device: Device,
        direction: AntennaMode,
        confidence: float = 1.0,
        tolerance: float = 0.0,
        min_num_samples: int = 1024,
        plot_scale: str = "linear",
        tick_format: ValueType = ValueType.LIN,
        plot_surface: bool = True,
    ) -> None:
        """
        Args:
            device: The device to evaluate the *PAPR* of.
            direction:
                The direction of the *PAPR* evaluation. Can be ``AntennaMode.TX`` or ``AntennaMode.RX``.
            confidence: Required confidence level for the given `tolerance` between zero and one.
            tolerance: Acceptable non-negative bound around the mean value of the estimated scalar performance indicator.
            min_num_samples: Minimum number of samples required to compute the confidence bound.
            plot_scale: Scale of the plot. Can be ``'linear'`` or ``'log'``.
            tick_format: Tick format of the plot.
            plot_surface: Enable surface plotting for two-dimensional grids. Enabled by default.
        """

        # Assert antenn mode validity
        if direction not in (AntennaMode.TX, AntennaMode.RX):
            raise ValueError("PAPR evaluator only supports TX and RX antenna modes")

        # Initialize the base class
        ScalarEvaluator.__init__(
            self, confidence, tolerance, min_num_samples, plot_scale, tick_format, plot_surface
        )

        # Initialize class members
        self.__direction = direction

        # Register hooks
        if direction == AntennaMode.TX:
            self.__output_hook = device.output_callbacks.add_callback(self.__output_callback)
            self.__input_hook = None

        elif direction == AntennaMode.RX:
            self.__output_hook = None
            self.__input_hook = device.input_callbacks.add_callback(self.__input_callback)

    def __output_callback(self, output: DeviceOutput) -> None:
        """Callback function notifying the evaluator of a new output."""

        self.__output = output

    def __input_callback(self, input: ProcessedDeviceInput) -> None:
        """Callback function notifying the evaluator of a new input."""

        self.__input = input

    @property
    @override
    def abbreviation(self) -> str:
        return "PAPR"

    @property
    @override
    def title(self) -> str:
        return "Peak-to-Average Power Ratio"

    @override
    def evaluate(self) -> PAPREvaluation:
        # Fetch the output or input signal
        signal: Signal
        if self.__direction == AntennaMode.TX:
            if self.__output is None:
                raise RuntimeError(
                    "PAPR evaluator could not fetch output. Has the assigned device transmitted data?"
                )
            signal = self.__output.mixed_signal

        elif self.__direction == AntennaMode.RX:
            if self.__input is None:
                raise RuntimeError(
                    "PAPR evaluator could not fetch input. Has the assigned device received data?"
                )
            signal = self.__input.impinging_signals[0]

        else:
            raise RuntimeError("Invalid direction flag for PAPR evaluator")

        # Compute the instantaneous power of the signal as an intermediate result
        signal_samples = signal.getitem((slice(None)))
        instantaneous_power = signal_samples.real**2 + signal_samples.imag**2

        return PAPREvaluation(instantaneous_power)

    @override
    def initialize_result(self, grid: Sequence[GridDimensionInfo]) -> ScalarEvaluationResult:
        return ScalarEvaluationResult(grid, self, self.tolerance, self.confidence)

    def __del__(self) -> None:
        if self.__output_hook is not None:
            self.__output_hook.remove()
        if self.__input_hook is not None:
            self.__input_hook.remove()


class SignalExtraction(Evaluation, Artifact):
    
    __signal: Signal
    
    def __init__(self, signal: Signal) -> None:
        """
        Args:
            signal: The base-band signal to extract.
        """

        # Initialize the base class
        Evaluation.__init__(self)
        Artifact.__init__(self)

        # Initialize attributes
        self.__signal = signal

    @property
    def signal(self) -> Signal:
        """The extracted base-band signal."""

        return self.__signal

    @override
    def artifact(self) -> SignalExtraction:
        """Returns the signal extraction as an artifact.

        For signal extraction, the artifact is the same as the evaluation.
        """

        return self

    @override
    def __str__(self) -> str:
        return ""

    @override
    def to_scalar(self) -> None:
        """Scalar representation of the signal extraction.

        Not available, therefore always returns :py:obj:`None`.
        """
        return None

    @override
    def _prepare_visualization(self, figure, axes, **kwargs):
        return self.__signal._prepare_visualization(figure, axes, **kwargs)

    @override
    def _update_visualization(self, visualization, **kwargs):
        self.__signal._update_visualization(visualization, **kwargs)


class ExtractedSignals(EvaluationResult[SignalExtraction]):
    """Result of a signal extraction evaluation.

    Stores the extracted signal samples in a grid structure.
    """

    __signal_stash: np.ndarray

    def __init__(
        self,
        grid: Sequence[GridDimensionInfo],
        evaluator: Evaluator | None = None,
        base_dimension_index: int = 0,
    ) -> None:
        """
        Args:
            grid: The grid of the evaluation result.
            evaluator: The evaluator that produced this result.
            base_dimension_index: The index of the base dimension used for plotting.
        """

        # Initialize the base class
        EvaluationResult.__init__(self, grid, evaluator, base_dimension_index)

        # Initialize signal stash
        self.__signal_stash = np.empty([d.num_sample_points for d in grid], dtype=object)
        for grid_coordinates in np.ndindex(self.__signal_stash.shape):
            self.__signal_stash[grid_coordinates] = []

    @override
    def add_artifact(self, coordinates: tuple[int, ...], artifact: SignalExtraction, compute_confidence:bool = True) -> bool:
        self.__signal_stash[coordinates].append(artifact.signal)
        return False

    @override
    def runtime_estimates(self) -> None:
        return None

    @override
    def to_array(self) -> np.ndarray:
        # Find the maximum number of samples in the signal stash
        max_samples = 0
        max_streams = 0
        max_signals = 0
        signals: list[Signal]
        for signals in self.__signal_stash.flat:
            max_signals = max(max_signals, len(signals))
            for signal in signals:
                max_samples = max(max_samples, signal.num_samples)
                max_streams = max(max_streams, signal.num_streams)

        # Create an array to hold the signals
        samples_array = np.zeros(([d.num_sample_points for d in self.grid] + [max_signals, max_streams, max_samples]), dtype=complex)

        # Fill the array with the signals
        for grid_coordinates, signals in np.ndenumerate(self.__signal_stash):
            sample_offset = 0
            for s, signal in enumerate(signals):
                samples_array[grid_coordinates + (s, slice(0, signal.num_streams), slice(sample_offset, sample_offset + signal.num_samples))] = signal.getitem((slice(None), slice(None)))

        return samples_array


class SignalExtractor(Evaluator):
    """Evaluator extracting base-band sample sequences from DSP layour input or output streams.
    
    .. warning::
       Depending on the setup, this evaluator will create an
       enormous amount of data, which may lead to memory issues.
       If possible, signals should not be extracted from simulation runtimes.
    """

    __cached_signal: Signal | None
    __hook: Hook[OperationResult]
    
    def __init__(self, target: Transmitter | Receiver) -> None:
        
        # Init base class
        Evaluator.__init__(self)
    
        # Initialize attributes
        self.__cached_signal = None

        # Hook into the target's operation result
        if isinstance(target, Transmitter):
            self.__hook = target.add_transmit_callback(self.__operation_callback)
        elif isinstance(target, Receiver):
            self.__hook = target.add_receive_callback(self.__operation_callback)
        else:
            raise TypeError("Target must be a Transmitter or Receiver instance")

    def __operation_callback(self, operation_result: OperationResult) -> None:
        """Callback function notifying the evaluator of a new signal."""
        
        self.__cached_signal = operation_result.signal

    @override
    def evaluate(self) -> SignalExtraction:
        """Extracts the base-band sample sequences from the DSP layout input or output streams."""

        if self.__cached_signal is None:
            raise RuntimeError("Signal extractor could not fetch signal. Has the target transmitted or received data?")

        # Create a signal extraction artifact
        return SignalExtraction(self.__cached_signal)

    @override
    def initialize_result(self, grid: Sequence[GridDimensionInfo]) -> ExtractedSignals:
        return ExtractedSignals(grid, self)

    @override
    @property
    def abbreviation(self) -> str:
        return "SigExt"

    @override
    @property
    def title(self) -> str:
        return "Signal Extractor"

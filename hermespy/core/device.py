# -*- coding: utf-8 -*-
"""
===============
Device Modeling
===============

.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   classDiagram-v2

   direction RL

   class Device {

       topology
       carrier_frequency
       transmit()
       receive()
   }

   class SimulatedDevice {

       position
       orientation
       velocity
       acceleration
   }

   class HardwareDevice {

       trigger()
   }

   class Operator {

       transmit()
       receive()
   }

   class Modem {

       tx_bits
       rx_bits
       ...
       waveform
       transmit()
       receive()
   }

   class Radar {

       waveform
       ...
       target_estimates
       transmit()
       receive()
   }

   Operator <|-- Modem
   Operator <|-- Radar
   Device *-- Operator
   SimulatedDevice <|-- Device
   HardwareDevice <|-- Device


.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   flowchart LR

   channel{Real World}

   subgraph devicea[HardwareDevice]

       direction TB
       deviceatx>Tx Slot] --> deviceabinding[Hardware Binding] --> devicearx>Rx Slot]

   end

   subgraph deviceb[HardwareDevice]

       direction TB
       devicebtx>Tx Slot] --> devicebbinding[Hardware Binding] --> devicebrx>Rx Slot]
   end

   deviceabinding <--> channel
   devicebbinding <--> channel

.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   flowchart LR

   channel{Channel Modeling}

   subgraph devicea[SimulatedDevice]

       direction TB
       deviceatx>Tx Slot]
       devicearx>Rx Slot]

   end

   subgraph deviceb[SimulatedDevice]

       direction TB
       devicebtx>Tx Slot]
       devicebrx>Rx Slot]
   end

   deviceatx --> channel --> devicearx
   devicebtx --> channel --> devicebrx

"""

from __future__ import annotations
from abc import ABC, abstractmethod
from collections.abc import Sequence
from itertools import chain
from math import ceil
from typing import Generic, Iterator, List, Optional, overload, Tuple, Type, TypeVar

import numpy as np
from h5py import Group
from scipy.constants import speed_of_light

from .antennas import AntennaArrayBase, UniformArray, IdealAntenna
from .definitions import SNRType
from .channel_state_information import ChannelStateInformation
from .factory import HDFSerializable, Serializable
from .random_node import RandomNode
from .signal_model import Signal
from .transformation import Transformable, Transformation


__author__ = "Jan Adler"
__copyright__ = "Copyright 2022, Barkhausen Institut gGmbH"
__credits__ = ["Jan Adler"]
__license__ = "AGPLv3"
__version__ = "1.0.0"
__maintainer__ = "Jan Adler"
__email__ = "jan.adler@barkhauseninstitut.org"
__status__ = "Prototype"


class FloatingError(RuntimeError):
    """Exception raised if an operation fails due to a currently being considered floating."""

    pass


OperationResultType = TypeVar("OperationResultType", bound="OperationResult")
"""Type of OperationResult"""


OperatorType = TypeVar("OperatorType", bound="Operator")
"""Type of operator."""


DeviceType = TypeVar("DeviceType", bound="Device")
"""Type of device."""


class OperationResult(HDFSerializable):
    """Base class for outputs of device operators."""

    signal: Signal
    """Base-band waveform."""

    def __init__(self, signal: Signal) -> None:
        """
        Args:

            signal (signal):
                Base-band waveform model.
        """

        self.signal = signal

    @classmethod
    def from_HDF(cls: Type[OperationResultType], group: Group) -> OperationResultType:
        signal = Signal.from_HDF(group["signal"])
        return cls(signal=signal)

    def to_HDF(self, group: Group) -> None:
        self.signal.to_HDF(self._create_group(group, "signal"))


class Transmission(OperationResult):
    """Information generated by transmitting over a transmit operator."""

    ...  # pragma: no cover


class Reception(OperationResult):
    """Information generated by receiving over a receive operator."""

    ...  # pragma: no cover


ReceptionType = TypeVar("ReceptionType", bound=Reception)
"""Type of operator reception"""


SlotType = TypeVar("SlotType", bound="OperatorSlot")
"""Type of slot."""


class Operator(Generic[SlotType], Serializable):
    """Base class for operators of devices.

    In HermesPy, operators may configure devices, broadcast signals over them or capture signals from them.
    Each operator is attached to a single device instance it operates on.
    """

    property_blacklist = {"slot"}

    __slot: Optional[SlotType]  # Slot within a device this operator 'operates'

    def __init__(self, slot: Optional[SlotType] = None) -> None:
        """
        Args:
            slot (OperatorSlot, optional):
                Device slot this operator is attached to.
                By default, the operator is not attached and considered floating.
        """

        self.slot = slot

    @property
    def slot(self) -> Optional[OperatorSlot]:
        """Device slot this operator operates.

        Returns:
            Handle to the device slot.
            `None` if the operator is currently considered floating.
        """

        return self.__slot

    @slot.setter
    def slot(self, value: Optional[SlotType]) -> None:
        """Set device slot this operator operates on."""

        # A None argument indicates the slot should be unbound
        if value is None:
            if hasattr(self, "_Operator__slot") and self.__slot is not None:
                # This is necessary to prevent event-loops. Just ignore it.
                slot = self.__slot
                self.__slot = None

                if slot.registered(self):
                    slot.remove(self)

            else:
                self.__slot = None

        elif not hasattr(self, "_Operator__slot"):
            self.__slot = value

            if not self.__slot.registered(self):
                self.__slot.add(self)

        elif self.__slot is not value:
            # if self.__slot is not None and self.__slot.registered(self):
            #    self.__slot.remove(self)

            self.__slot = value

            if not self.__slot.registered(self):
                self.__slot.add(self)

    @property
    def slot_index(self) -> Optional[int]:
        """Index of the operator within its slot.

        Returns:
            Index of the operator.
            `None` if the operator is currently considered floating.
        """

        if self.__slot is None:
            return None

        return self.__slot.operator_index(self)

    @property
    def device(self) -> Optional[Device]:
        """Device this operator is attached to.

        Returns:
            device (Optional[Device]):
                Handle to the operated device.
                `None` if the operator is currently considered floating.
        """

        if self.__slot is None:
            return None

        return self.__slot.device

    @property
    def attached(self) -> bool:
        """Attachment state of the operator.

        Returns:
            bool: Boolean attachment indicator
        """

        return self.__slot is not None

    @property
    @abstractmethod
    def frame_duration(self) -> float:
        """Duration of a single sample frame.

        Returns:
            duration (float): Frame duration in seconds.
        """
        ...  # pragma: no cover

    @property
    @abstractmethod
    def sampling_rate(self) -> float:
        """The operator's preferred sampling rate.

        Returns:

            Sampling rate in Hz.
        """
        ...  # pragma: no cover


class DeviceOutput(HDFSerializable):
    """Base class for the output of a device."""

    __mixed_signal: Signal | None

    def __init__(self, mixed_signal: Signal) -> None:
        """
        Args:

            mixed_signal (Signal): Mixed signal emerging from the device.
        """

        self.__mixed_signal = mixed_signal

    @property
    def sampling_rate(self) -> float:
        """Sampling rate at which the device operates.


        Returns: Sampling rate in Hz.
        """

        return self.__mixed_signal.sampling_rate

    @property
    def num_antennas(self) -> int:
        """Number of transmitting device antennas.

        Returns: Number of antennas.
        """

        return self.__mixed_signal.num_streams

    @property
    def carrier_frequency(self) -> float:
        """Carrier frequency at which the device operates.

        Returns: Carrier frequency in Hz.
        """

        return self.__mixed_signal.carrier_frequency

    @property
    def emerging_signals(self) -> Sequence[Signal]:
        """Models of electromagnetic signals generated by the device.

        Returns: List of signal models.
        """

        return [self.__mixed_signal]

    @property
    def num_emerging_signals(self) -> int:
        """Number of emerging signal models.

        Returns: Count of models.
        """

        return len(self.emerging_signals)

    @property
    def mixed_signal(self) -> Signal:
        """Combined signal of the device's transmissions.

        Returns: Signal model of the device's electromagnetic transmission.
        """

        return self.__mixed_signal

    @classmethod
    def from_HDF(cls: Type[DeviceOutput], group: Group) -> DeviceOutput:
        # Recall serialized mixed signal group
        mixed_signal = Signal.from_HDF(group["mixed_signal"])

        # Initialize object
        return cls(mixed_signal)

    def to_HDF(self, group: Group) -> None:
        # Serialize groups
        self.mixed_signal.to_HDF(self._create_group(group, "mixed_signal"))


class DeviceTransmission(DeviceOutput):
    """Information generated by transmitting over a device."""

    __operator_transmissions: Sequence[Transmission]

    def __init__(self, operator_transmissions: Sequence[Transmission], mixed_signal: Signal) -> None:
        """
        Args:

            operator_transmissions (Sequence[Transmission]):
                List of information generated by transmit operators.

            mixed_signal (Signal):
                Mixed signal transmitted by the device.
        """

        # Initialize base class
        DeviceOutput.__init__(self, mixed_signal)

        # Initialze class attributes
        self.__operator_transmissions = operator_transmissions

    @classmethod
    def From_Output(cls: Type[DeviceTransmission], output: DeviceOutput, operator_transmissions: Sequence[Transmission]) -> DeviceTransmission:
        """Initialize a device transmission from a device output.

        Args:

            output (DeviceOutput):
                Device output object.

            operator_transmissions (List[Transmission]):
                List of information generated by transmit operators.
        """

        return cls(operator_transmissions, output.mixed_signal)

    @property
    def operator_transmissions(self) -> Sequence[Transmission]:
        """Information transmitted by device operators.

        Returns: Operator information.
        """

        return self.__operator_transmissions

    @property
    def num_operator_transmissions(self) -> int:
        """Number of operator transmissions."""

        return len(self.__operator_transmissions)

    @classmethod
    def from_HDF(cls: Type[DeviceTransmission], group: Group) -> DeviceTransmission:
        # Recall base class
        device_output = DeviceOutput.from_HDF(group)

        # Recall attributes
        num_transmissions = group.attrs.get("num_transmissions", 1)

        # Recall transmissions
        transmissions = [Transmission.from_HDF(group[f"transmission_{t:02d}"]) for t in range(num_transmissions)]

        # Initialize object
        return cls.From_Output(device_output, transmissions)

    @classmethod
    def Recall(cls: Type[DeviceTransmission], group: Group, device: Device) -> DeviceTransmission:
        # Recall base class
        device_output = DeviceOutput.from_HDF(group)

        # Recall attributes
        num_transmissions = group.attrs.get("num_transmissions", 1)

        transmissions = [transmitter.recall_transmission(group[f"transmission_{t:02d}"]) for t, transmitter in zip(range(num_transmissions), device.transmitters)]

        # Initialize object
        return cls.From_Output(device_output, transmissions)

    def to_HDF(self, group: Group) -> None:
        # Serialize base class
        DeviceOutput.to_HDF(self, group)

        # Serialize attributes
        group.attrs["num_transmissions"] = self.num_operator_transmissions

        # Serialize groups
        for t, transmission in enumerate(self.operator_transmissions):
            transmission.to_HDF(group.create_group(f"transmission_{t:02d}"))


class DeviceInput(HDFSerializable):
    """Receive information required by devices."""

    __impinging_signals: Sequence[Signal]

    def __init__(self, impinging_signals: Signal | Sequence[Signal]) -> None:
        """
        Args:

            impinging_signals (Union[Signal, List[Signal]]): Signals to be processed by the device.
        """

        impinging_signals = [impinging_signals] if isinstance(impinging_signals, Signal) else impinging_signals
        self.__impinging_signals = impinging_signals

    @property
    def impinging_signals(self) -> Sequence[Signal]:
        """Signals to be processed by the device.

        Returns: List of signal models.
        """

        return self.__impinging_signals

    @property
    def num_impinging_signals(self) -> int:
        """Number of signals impinging onto the device.

        Returns: Signal model count.
        """

        return len(self.__impinging_signals)

    @classmethod
    def from_HDF(cls: Type[DeviceInput], group: Group) -> DeviceInput:
        num_impinging_signals = group.attrs.get("num_impinging_signals", 1)
        impinging_signals = [Signal.from_HDF(group[f"impinging_signal_{s:02d}"]) for s in range(num_impinging_signals)]

        return cls(impinging_signals)

    def to_HDF(self, group: Group) -> None:
        # Serialize groups
        for s, signal in enumerate(self.impinging_signals):
            signal.to_HDF(group.create_group(f"impinging_signal_{s:02d}"))

        # Serialize attributes
        group.attrs["num_impinging_signals"] = self.num_impinging_signals


class ProcessedDeviceInput(DeviceInput):
    """Information generated by receiving over a device."""

    __operator_inputs: Sequence[Tuple[Signal, ChannelStateInformation | None]]

    def __init__(self, impinging_signals: DeviceInput | Signal | Sequence[Signal], operator_inputs: Sequence[Tuple[Signal, ChannelStateInformation | None]]) -> None:
        """
        Args:

            impinging_signals (DeviceInput | Signal | Sequence[Signal]):
                Numpy vector containing lists of signals impinging onto the device.

            operator_inputs (Sequence[Tuple[Signal, ChannelStateInformation | None]]):
                Information cached by the device operators.
        """

        if isinstance(impinging_signals, DeviceInput):
            impinging_signals = impinging_signals.impinging_signals

        # Initialize base class
        DeviceInput.__init__(self, impinging_signals)

        # Initialize attributes
        self.__operator_inputs = operator_inputs

    @property
    def operator_inputs(self) -> Sequence[Tuple[Signal, ChannelStateInformation | None]]:
        return self.__operator_inputs

    @property
    def num_operator_inputs(self) -> int:
        """Number of operator inputs.

        Returns: Input count.
        """

        return len(self.__operator_inputs)

    @classmethod
    def from_HDF(cls: Type[ProcessedDeviceInput], group: Group) -> ProcessedDeviceInput:
        # Recall base class
        device_input = DeviceInput.from_HDF(group)

        # Recall individual detected frames
        num_inputs = group.attrs.get("num_operator_inputs", 0)
        operator_inputs = [(Signal.from_HDF(group[f"operator_input_{i:02d}"]), None) for i in range(num_inputs)]

        return cls(device_input, operator_inputs)

    def to_HDF(self, group: Group) -> None:
        # Serialize base class
        DeviceInput.to_HDF(self, group)

        # Serialize groups
        for i, (input_signal, _) in enumerate(self.operator_inputs):
            input_signal.to_HDF(group.create_group(f"operator_input_{i:02d}"))

        # Serialize attributes
        group.attrs["num_operator_inputs"] = self.num_operator_inputs


DRT = TypeVar("DRT", bound="DeviceReception")
"""Type of device reception."""


class DeviceReception(ProcessedDeviceInput):
    """Information generated by receiving over a device and its operators."""

    __operator_receptions: Sequence[Reception]

    def __init__(self, impinging_signals: Signal | Sequence[Signal], operator_inputs: Sequence[Tuple[Signal, ChannelStateInformation | None]], operator_receptions: Sequence[Reception]) -> None:
        """
        Args:

            impinging_signals (Signal | Sequence[Signal]):
                Numpy vector containing lists of signals impinging onto the device.

            operator_inputs (Sequence[Tuple[Signal, ChannelStateInformation | None]]):
                Information cached by the device operators.

            operator_separation (bool):
                Is the operator separation flag enabled?

            operator_receptions (Sequence[Reception]):
                Information inferred from receive operators.
        """

        # Initialize base class
        ProcessedDeviceInput.__init__(self, impinging_signals, operator_inputs)

        # Initialize attributes
        self.__operator_receptions = operator_receptions

    @classmethod
    def From_ProcessedDeviceInput(cls: Type[DRT], device_input: ProcessedDeviceInput, operator_receptions: Sequence[Reception]) -> DRT:
        """Initialize an instance from a processed device input.

        Args:

            device_input (ProcessedDeviceInput):
                The processed device output.

            operator_receptions (List[OperatorReceptions]):
                List of operator receptions.

        Returns: The initialized object.
        """

        return cls(device_input.impinging_signals, device_input.operator_inputs, operator_receptions)

    @property
    def operator_receptions(self) -> Sequence[Reception]:
        """Information transmitted by device operators.

        Returns: Operator information.
        """

        return self.__operator_receptions

    @property
    def num_operator_receptions(self) -> int:
        """Number of operator receptions.

        Returns: Number of receptions.
        """

        return len(self.__operator_receptions)

    @classmethod
    def from_HDF(cls: Type[DRT], group: Group) -> DRT:
        # Recall base class
        device_input = ProcessedDeviceInput.from_HDF(group)

        # Recall individual operator receptions
        num_receptions = group.attrs.get("num_operator_receptions", 0)

        # Recall operator receptions
        operator_receptions = [Reception.from_HDF(group[f"reception_{f:02d}"]) for f in range(num_receptions)]

        # Initialize object
        return cls.From_ProcessedDeviceInput(device_input, operator_receptions)

    @classmethod
    def Recall(cls: Type[DRT], group: Group, device: Device) -> DRT:
        # Recall base class
        device_input = ProcessedDeviceInput.from_HDF(group)

        # Recall individual operator receptions
        num_receptions = group.attrs.get("num_operator_receptions", 0)

        # recall operator receptions
        receptions = [receiver.recall_reception(group[f"reception_{r:02d}"]) for r, receiver in zip(range(num_receptions), device.receivers)]

        # Initialize object
        return cls.From_ProcessedDeviceInput(device_input, receptions)

    def to_HDF(self, group: Group) -> None:
        # Serialize base class
        ProcessedDeviceInput.to_HDF(self, group)

        # Serialize groups
        for t, reception in enumerate(self.operator_receptions):
            reception.to_HDF(group.create_group(f"reception_{t:02d}"))

        # Serialize attributes
        group.attrs["num_operator_receptions"] = self.num_operator_receptions


class MixingOperator(Generic[SlotType], Operator[SlotType], ABC):
    """Base class for operators performing mixing operations."""

    __carrier_frequency: Optional[float]  # Carrier frequency

    def __init__(self, carrier_frequency: Optional[float] = None, slot: Optional[SlotType] = None) -> None:
        """
        Args:

            carrier_frequency (float, optional):
                Central frequency of the mixed signal in radio-frequency transmission band.

            slot (SlotType, optional):
                Device slot this operator operators.
        """

        self.carrier_frequency = carrier_frequency
        Operator.__init__(self, slot)

    @property
    def carrier_frequency(self) -> float:
        """Central frequency of the mixed signal in radio-frequency transmission band.

        By default, the carrier frequency of the operated device is returned.
        If no device is being operated, we assume a base band, i.e. carrier frequency of zero.

        Returns:
            float: Carrier frequency in Hz.

        Raises:
            ValueError: If the carrier frequency is smaller than zero.
        """

        if self.__carrier_frequency is None:
            if self.device is None:
                return 0.0

            else:
                return self.device.carrier_frequency

        return self.__carrier_frequency

    @carrier_frequency.setter
    def carrier_frequency(self, value: Optional[float]) -> None:
        """Set the central frequency of the mixed signal in radio-frequency transmission band."""

        if value is None:
            self.__carrier_frequency = None
            return

        if value < 0.0:
            raise ValueError("Carrier frequency must be greater or equal to zero")

        self.__carrier_frequency = value


class Receiver(RandomNode, MixingOperator["ReceiverSlot"], Generic[ReceptionType]):
    """Operator receiving from a device."""

    __reference: Device | None
    __signal: Signal | None
    __csi: ChannelStateInformation | None
    __reception: ReceptionType | None

    def __init__(self, seed: int | None = None, reference: Device | None = None, *args, **kwargs) -> None:
        """
        Args:

            seed (int, optional):
                Random seed used to initialize the pseudo-random number generator.

            reference (Device, optional):
                Reference device to which the channel shall be estimated.

            *args:
                Operator base class initialization parameters.

            **kwargs:
                Operator base class initialization parameters.
        """

        # Initialize base classes
        RandomNode.__init__(self, seed=seed)
        MixingOperator.__init__(self, *args, **kwargs)

        self.reference = reference
        self.__signal = None
        self.__csi = None
        self.__reception = None

    @Operator.device.setter  # type: ignore
    def device(self, value: Device) -> None:  # type: ignore
        value.receivers.add(self)

    @Operator.slot.setter  # type: ignore
    def slot(self, value: Optional[ReceiverSlot]) -> None:
        Operator.slot.fset(self, value)  # type: ignore
        self.random_mother = None if value is None else value.device

    @property
    def reference(self) -> Optional[Device]:
        """Reference transmitter for this receiver.

        Returns:
            A handle to the referenced device.
            `None` if the device was not specified.
        """

        return self.__reference

    @reference.setter
    def reference(self, value: Optional[Device]) -> None:
        self.__reference = value

    @property
    def reception(self) -> Optional[ReceptionType]:
        """Information generated from the recent reception.

        Updated when calling :meth:`.receive`.

        Returns:
            The cached information.
            `None` if :meth:`.receive` has not been called yet.
        """

        return self.__reception

    def receive(self, signal: Optional[Signal] = None, csi: Optional[ChannelStateInformation] = None, cache: bool = True) -> ReceptionType:
        """Process a received signal by the receiver.

        Wrapper around the abstract :meth:`._receive` method.

        Args:

            signal (Signal, optional): Signal model to be processed.
            csi (ChannelStateInformation, optional): Channel state information.
            cache (bool, optional): Cache the received information

        Returns: Information rceived by this operator.

        Raises:

            RuntimeError: If signal model was not provided and no signal is cached.
        """

        if signal is None:
            if self.signal is None:
                raise RuntimeError("Error attempting to fetch a cached receiver signal")

            signal = self.signal

        csi = self.csi if csi is None else csi

        # Generate received information
        reception = self._receive(signal, csi)

        # Cache the reception if the respective flag is enabled
        if cache:
            self.__reception = reception

        # Return received information
        return reception

    @abstractmethod
    def _receive(self, signal: Signal, csi: ChannelStateInformation) -> ReceptionType:
        """Process a received signal by the receiver.

        Pulls the required signal model and channel state information from the underlying device.

        Args:

            signal (Signal, optional): Signal model to be processed.
            csi (ChannelStateInformation, optional): Channel state information.

        Returns: Information rceived by this operator.
        """
        ...  # pragma: no cover

    @property
    def signal(self) -> Optional[Signal]:
        """Cached recently received signal model.

        Returns:
            signal (Optional[Signal]):
                Signal model.
                `None` if no signal model is cached.
        """

        return self.__signal

    @property
    def csi(self) -> Optional[ChannelStateInformation]:
        """Cached recently received channel state information

        Returns:
            csi (Optional[ChannelStateInformation]):
                Channel state information.
                `None` if no state information is cached.
        """

        return self.__csi

    def cache_reception(self, signal: Optional[Signal], csi: Optional[ChannelStateInformation] = None) -> None:
        """Cache recent reception at this receiver.

        Args:

            signal (Optional[Signal]):
                Recently received signal.

            csi (Optional[ChannelStateInformation]):
                Recently received channel state.
        """

        self.__signal = signal
        self.__csi = csi

    def recall_reception(self, group: Group, cache: bool = True) -> ReceptionType:
        """Recall a specific reception from a serialization.

        Internally calls the abstract method :meth:`Receiver._recall_reception`.
        Caches the reception if the respective flag is enabled.

        Args:

            group (Group):
                HDF group containing the reception.

            cache (bool, optional):
                Cache the reception.
                Enabled by default.

        Returns: The recalled reception.
        """

        recalled_reception = self._recall_reception(group)

        if cache:
            self.__reception = recalled_reception

        return recalled_reception

    @abstractmethod
    def _recall_reception(self, group: Group) -> ReceptionType:
        """Recall a specific reception from a serialization.

        Args:

            group (Group):
                HDF group containing the reception.

        Returns: The recalled reception.
        """
        ...  # pragma: no cover

    def noise_power(self, strength: float, snr_type: SNRType) -> float:
        """Compute noise power for a given signal strength.

        Internally calls :meth:`._noise_power` for some `snr_type`s.

        Args:

            strength (float):
                Signal strength indicator.
                The unit depends on `snr_type`.

            snr_type (SNRType):
                The considered signal to noise ratio type.

        Raises:

            ValueError: If the receiver does not support the required snr type.
        """

        # For the N0 snr_type the receiver implementation must not be queried
        if snr_type is SNRType.N0:
            return strength

        return self._noise_power(strength, snr_type)

    @abstractmethod
    def _noise_power(self, strength: float, snr_type: SNRType) -> float:
        """Compute noise power for a given signal strength.

        Args:

            strength (float):
                Signal strength indicator.
                The unit depends on `snr_type`.

            snr_type (SNRType):
                The considered signal to noise ratio type.

        Raises:

            ValueError: If the receiver does not support the required snr type.
        """
        ...  # pragma: no cover


class OperatorSlot(Generic[OperatorType], Sequence[OperatorType]):
    """Slot list for operators of a single device."""

    __device: Device  # Device this operator belongs to
    __operators: List[OperatorType]  # List of operators registered at this slot

    def __init__(self, device: Device) -> None:
        """
        Args:

            device (Device):
                Device this slot belongs to.
        """

        self.__device = device
        self.__operators = []

    @property
    def device(self) -> Device:
        """Device this operator slot belongs to.

        Returns:
            Device: Handle to the device.
        """

        return self.__device

    def operator_index(self, operator: OperatorType) -> int:
        """Index of an operator within this slot.

        Returns:
            index (int): The `operator`'s index.

        Raises:
            ValueError: If the `operator` is not registered at this slot.
        """

        return self.__operators.index(operator)

    def add(self, operator: OperatorType) -> None:
        """Add a new operator to this slot.

        Args:
            operator (OperatorType):
                Operator to be added to this slot.

        Raises:
            RuntimeError: If the `operator` is already registered at this slot.
        """

        # Do nothing if the operator is already registered
        if operator in self.__operators:
            return

        self.__operators.append(operator)
        operator.slot = self

    def remove(self, operator: OperatorType) -> None:
        """Remove an operator from this slot.

        Args:
            operator (OperatorType):
                Handle to the operator to be removed.
        """

        if operator in self.__operators:
            self.__operators.remove(operator)

        operator.slot = None

    def registered(self, operator: OperatorType) -> bool:
        """Check if an operator is registered at this slot.

        Returns:
            bool: Boolean indicating the registration status.
        """

        return operator in self.__operators

    @property
    def num_operators(self) -> int:
        """Number of operators on this slot.

        Returns:
            int: Number of operators.
        """

        return len(self.__operators)

    @property
    def max_sampling_rate(self) -> float:
        """Maximum requested sampling rate of all operators.

        Returns:

            The maximum sampling rate in Hz.
        """

        sampling_rate = 0.0

        for operator in self.__operators:
            sampling_rate = max(sampling_rate, operator.sampling_rate)

        return sampling_rate

    @property
    def min_frame_duration(self) -> float:
        """The mininum frame duration requried to process at least a single frame for each operator.

        Returns:

            The minimum frame duration in seconds.
        """

        frame_duration = 0.0

        for operator in self.__operators:
            frame_duration = max(frame_duration, operator.frame_duration)

        return frame_duration

    @property
    def min_num_samples_per_frame(self) -> int:
        """The number of samples required to collect at last a single frame for each operator.

        Returns:

            Number of samples.
        """

        sampling_rate = self.max_sampling_rate
        frame_duration = self.min_frame_duration

        return ceil(frame_duration * sampling_rate)

    @overload
    def __getitem__(self, item: int) -> OperatorType:
        ...  # pragma:  no cover

    @overload
    def __getitem__(self, item: slice) -> Sequence[OperatorType]:
        ...  # pragma: no cover

    def __getitem__(self, item: int | slice) -> OperatorType | Sequence[OperatorType]:
        return self.__operators[item]

    def __iter__(self) -> Iterator[OperatorType]:
        """Iterating over operator slots returns the iterator over the slots."""

        return self.__operators.__iter__()

    def __contains__(self, operator: object) -> bool:
        """Contains is just a convenient mask for registered.

        Returns: Registration indicator.
        """

        return operator in self.__operators

    def __len__(self) -> int:
        return self.num_operators


TransmissionType = TypeVar("TransmissionType", bound="Transmission")


class Transmitter(Generic[TransmissionType], RandomNode, MixingOperator["TransmitterSlot"]):
    """Operator transmitting over a device."""

    __transmission: TransmissionType | None

    def __init__(self, seed: Optional[int] = None, *args, **kwargs) -> None:
        """
        Args:

            seed (int, optional):
                Random seed used to initialize the pseudo-random number generator.

            *args:
                Operator base class initialization parameters.

            **kwargs:
                Operator base class initialization parameters.
        """

        # Initialize operator base class
        RandomNode.__init__(self, seed=seed)
        MixingOperator.__init__(self, *args, **kwargs)

        # Initialize class attributes
        self.__transmission = None

    def transmit(self, duration: float = 0.0, cache: bool = True) -> TransmissionType:
        """Transmit a signal.

        Registers the signal samples to be transmitted by the underlying device.

        Wrapper around the abstract :meth:`._transmit` method.

        Args:

            duration (float, optional):
                Duration of the transmitted signal.
                If not specified, the duration will be inferred by the transmitter.

            cache (bool, optional):
                Cache the transmission by the transmitter.
                Enabled by default.

        Returns:

            Information generated while transmitting over this operator.

        Raises:

            FloatingError: If the transmitter is currently considered floating.
        """

        transmission = self._transmit(duration)

        if cache:
            self.__transmission = transmission

        return transmission

    @abstractmethod
    def _transmit(self, duration: float) -> TransmissionType:
        """Generate information transmitted by the transmitter.

        duration (float, optional):
            Duration of the transmitted signal.
            If not specified, the duration will be inferred by the transmitter.

        Returns: The transmitted information.
        """
        ...  # pragma: no cover

    @property
    def transmission(self) -> TransmissionType | None:
        """Recent transmission of the transmitter.

        Updated during the :meth:`.transmit` routine.

        Returns:
            The recent transmission.
            `None` if the cache has been cleared or :meth:`.transmit` has not been called yet.
        """

        return self.__transmission

    def cache_transmission(self, transmission: TransmissionType) -> None:
        """Cache a transmission for this transmitter.

        Args:

            transmission (TransmissionType):
                The transmission to be cached.
        """

        self.__transmission = transmission

    def recall_transmission(self, group: Group, cache: bool = True) -> TransmissionType:
        """Recall a specific transmission from a serialization.

        Internally calls the abstract method :meth:`Transmitter._recall_transmission`.
        Caches the transmission if the respective flag is enabled.

        Args:

            group (Group):
                HDF group containing the transmission.

            cache (bool, optional):
                Cache the transmission.
                Enabled by default.

        Returns: The recalled transmission
        """

        recalled_transmission = self._recall_transmission(group)

        if cache:
            self.cache_transmission(recalled_transmission)

        return recalled_transmission

    @abstractmethod
    def _recall_transmission(self, group: Group) -> TransmissionType:
        """Recall a specific transmission from a serialization.

        Args:

            group (Group):
                HDF group containing the transmission.

        Returns: The recalled transmission
        """
        ...  # pragma: no cover

    @Operator.device.setter  # type: ignore
    def device(self, value: Device) -> None:  # type: ignore
        value.transmitters.add(self)

    @Operator.slot.setter  # type: ignore
    def slot(self, value: Optional[TransmitterSlot]) -> None:
        Operator.slot.fset(self, value)  # type: ignore
        self.random_mother = None if value is None else value.device


class TransmitterSlot(OperatorSlot[Transmitter]):
    """Slot for transmitting operators within devices."""

    # Next signals to be transmitted
    __transmissions: List[Optional[Transmission]]

    def __init__(self, *args, **kwargs) -> None:
        """
        Args:
            *args:
                OperatorSlot base class initialization parameters.

            **kwargs:
                OperatorSlot base class initialization parameters.
        """

        self.__transmissions = []

        # Init base class
        OperatorSlot.__init__(self, *args, **kwargs)

    def add(self, operator: Transmitter) -> None:
        OperatorSlot.add(self, operator)
        self.__transmissions.append(None)

    def add_transmission(self, transmitter: Transmitter, transmission: Transmission) -> None:
        """Add a transmitter's most recent transmission.

        Args:

            transmitter(Transmitter):
                The transmitter emitting the signal.

            transmission (OperatorTransmission):
                The information to be transmitted.

        Raises:
            ValueError: If the transmitter is not registered at this slot.
        """

        if not self.registered(transmitter):
            raise ValueError("Transmitter not registered at this slot")

        if transmission.signal.num_streams != self.device.num_antennas:
            raise ValueError(f"Transmitted signal has invalid number of streams ({transmission.signal.num_streams} instead of {self.device.num_antennas})")

        self.__transmissions[transmitter.slot_index] = transmission

    def get_transmissions(self, clear_cache: bool = True) -> List[Transmission]:
        """Get recent transmissions.

        Returns: A list of recent operator transmissions.
        """

        transmissions: List[Transmission] = self.__transmissions.copy()

        # Clear the cache if the respective flag is enabled
        if clear_cache:
            self.clear_cache()

        return transmissions

    def clear_cache(self) -> None:
        """Clear the cached transmission of all registered transmit operators."""

        self.__transmissions = [None] * self.num_operators


class ReceiverSlot(OperatorSlot[Receiver]):
    """Slot for receiving operators within devices."""

    def __init__(self, *args, **kwargs) -> None:
        """
        Args:
            *args:
                OperatorSlot base class initialization parameters.

            **kwargs:
                OperatorSlot base class initialization parameters.
        """

        # Init base class
        OperatorSlot.__init__(self, *args, **kwargs)


class UnsupportedSlot(OperatorSlot):
    """Slot for unsupported operations within devices."""

    def add(self, operator: Operator) -> None:
        raise RuntimeError("Slot not supported by this device")


class Device(ABC, Transformable, RandomNode, Serializable):
    """Physical device representation within HermesPy.

    It acts as the basis for all transmissions and receptions of sampled electromagnetic signals.
    """

    transmitters: TransmitterSlot
    """Transmitters broadcasting signals over this device."""

    receivers: ReceiverSlot
    """Receivers capturing signals from this device"""

    __antennas: AntennaArrayBase  # Model of the device's antenna array.
    __power: float  # Average power of the transmitted signals
    __received_signal: Optional[Signal]  # Recently received signal

    def __init__(self, antennas: Optional[AntennaArrayBase] = None, power: float = 1.0, pose: Transformation | None = None, seed: Optional[int] = None) -> None:
        """
        Args:

            antennas (AntennaArrayBase, optional):
                Model of the device's antenna array.
                By default, a :class:`UniformArray` of ideal antennas is assumed.

            power (float, optional):
                Average power of the transmitted signals in Watts.
                1.0 Watt by default.

            pose (Transformation, optional):
                Pose of the device with respect to its scenario coordinate system origin.

            seed (int, optional):
                Random seed used to initialize the pseudo-random number generator.
        """

        # Initialize base classes
        RandomNode.__init__(self, seed=seed)
        Transformable.__init__(self, pose=pose)

        # Initalize device attributes and properties
        self.antennas = UniformArray(IdealAntenna(), 5e-3, (1,)) if antennas is None else antennas
        self.transmitters = TransmitterSlot(self)
        self.receivers = ReceiverSlot(self)

        self.power = power
        self.__received_signal = None

    @property
    def antennas(self) -> AntennaArrayBase:
        """Model of the device's antenna array.

        Returns: The antenna array.
        """

        return self.__antennas

    @antennas.setter
    def antennas(self, value: AntennaArrayBase) -> None:
        # Update the internal antenna array reference
        self.__antennas = value

        # Register the device as the antenna array's reference frame
        self.__antennas.set_base(self)

    @property
    def power(self) -> float:
        """Average power of the transmitted signal signal.

        Returns:
            power (float): Power in Watt.

        Raises:
            ValueError: If `value` is smaller than zero.
        """

        return self.__power

    @power.setter
    def power(self, value: float) -> None:
        """Set the average power of the transmitted signal."""

        if value < 0.0:
            raise ValueError("Average signal power must be greater or equal to zero")

        self.__power = value

    @property
    def snr(self) -> float:
        """Signal to noise ratio of the received signal.

        Returns: Linear signal to noise ratio
        """

        # By default, we have no knowledge about the snr and assum no noise
        return float("inf")

    @property
    def num_antennas(self) -> int:
        """Number of antennas within this device's topology.

        Returns:
            int: Number of antennas, greater or equal to one.
        """

        return self.__antennas.num_antennas

    @property
    def max_frame_duration(self) -> float:
        """Maximum frame duration transmitted by this device.

        Returns:
            max_duration (float): Maximum duration in seconds.
        """

        max_duration = 0.0

        for operator in chain(self.transmitters, self.receivers):
            max_duration = max(max_duration, operator.frame_duration)  # type: ignore

        return max_duration

    @property
    @abstractmethod
    def carrier_frequency(self) -> float:
        """Central frequency of the device's emissions in the RF-band.

        Returns:

            frequency (float):
                Carrier frequency in Hz.

        Raises:
            ValueError: On negative carrier frequencies.
        """
        ...  # pragma: no cover

    @property
    def wavelength(self) -> float:
        """Central wavelength of the device's emmissions in the RF-band.

        Returns:

            wavelength (float):
                Wavelength in m.

        Raises:
            ValueError:
                On wavelengths smaller or equal to zero.
        """

        return speed_of_light / self.carrier_frequency

    @property
    @abstractmethod
    def sampling_rate(self) -> float:
        """Sampling rate at which the device's analog-to-digital converters operate.

        Returns:
            sampling_rate (float): Sampling rate in Hz.

        Raises:
            ValueError: If the sampling rate is not greater than zero.
        """
        ...  # pragma: no cover

    @property
    @abstractmethod
    def velocity(self) -> np.ndarray:
        """Cartesian device velocity vector.

        Returns:
            np.ndarray: Velocity vector.

        Raises:
            ValueError: If `velocity` is not three-dimensional.
            NotImplementedError: If `velocity` is unknown.
        """
        ...  # pragma: no cover

    def transmit_operators(self) -> List[Transmission]:
        """Generate transmitted information for all registered operators.

        Calls :meth:`Transmitter.transmit` for each transmit operator.

        Returns: List of operator transmisisons.
        """

        return [transmitter.transmit() for transmitter in self.transmitters]

    def generate_output(self, operator_transmissions: Optional[List[Transmission]] = None) -> DeviceOutput:
        """Generate the device's output.

        Args:

            operator_transmissions (List[Transmissions], optional):
                List of operator transmissions from which to generate the output.
                If the `operator_transmissions` are not provided, the transmitter's caches will be queried.

        Returns: The device's output.

        Raises:

            RuntimeError: If no `operator_transmissions` were provided and an operator has no cached transmission.
        """

        # Generate operator transmissions if None were provided:
        operator_transmissions = [o.transmission for o in self.transmitters] if operator_transmissions is None else operator_transmissions

        if any([t is None for t in operator_transmissions]):
            raise RuntimeError("Error trying to generate outputs without specifying transmissions, caches are empty")

        # Superimpose the operator transmissions to the device's RF configuration
        superimposed_signal = Signal.empty(self.sampling_rate, self.antennas.num_transmit_antennas, carrier_frequency=self.carrier_frequency)

        for transmission in operator_transmissions:
            superimposed_signal.superimpose(transmission.signal)

        return DeviceOutput(superimposed_signal)

    def transmit(self, clear_cache: bool = True) -> DeviceTransmission:
        """Transmit over this device.

        Args:

            clear_cache (bool, optional):
                Clear the cache of operator signals to be transmitted.
                Enabled by default.

        Returns: Information transmitted by this device.
        """

        operator_transmissions = self.transmit_operators()
        device_output = self.generate_output(operator_transmissions)

        return DeviceTransmission.From_Output(device_output, operator_transmissions)

    def cache_transmission(self, transmission: DeviceTransmission) -> None:
        for transmitter, operator_transmission in zip(self.transmitters, transmission.operator_transmissions):
            transmitter.cache_transmission(operator_transmission)

    def process_input(self, impinging_signals: DeviceInput | Signal | Sequence[Signal], cache: bool = True) -> ProcessedDeviceInput:
        """Process input signals impinging onto this device.

        Args:

            impinging_signals (Union[DeviceInput, Signal, Sequence[Signal]]):
                The samples to be processed by the device.

            cache (bool, optional):
                Cache the operator inputs at the registered receive operators for further processing.
                Enabled by default.

        Returns: The processed device input information.

        Raises:

            ValueError: If the number of signal streams does not match the device configuration expectations.
        """

        # Convert argument
        impinging_signals = [impinging_signals] if isinstance(impinging_signals, Signal) else impinging_signals
        impinging_signals = impinging_signals.impinging_signals if isinstance(impinging_signals, DeviceInput) else impinging_signals

        # Superimpose the impinging signal models
        if len(impinging_signals) != 1:
            superimposed_signal = Signal.empty(self.sampling_rate, self.antennas.num_receive_antennas, carrier_frequency=self.carrier_frequency)
            for signal in impinging_signals:
                superimposed_signal.superimpose(signal)

        else:
            superimposed_signal = impinging_signals[0]

        # Each operator is fed the superimposed signal by default
        operator_inputs = [superimposed_signal for _ in self.receivers]

        # Cache the operator inputs if the respective flag is enabled
        if cache:
            receiver: Receiver
            for receiver, input in zip(self.receivers, operator_inputs):
                receiver.cache_reception(input)

        input_tuple = [(input, None) for input in operator_inputs]  # Hack for forwards compatibility, to be resolved
        return ProcessedDeviceInput(impinging_signals, input_tuple)

    def receive_operators(self, operator_inputs: ProcessedDeviceInput | Sequence[Tuple[Signal, ChannelStateInformation | None]] | None = None, cache: bool = True) -> List[Reception]:
        """Receive over the registered operators.

        Args:

            operator_inputs (ProcessedDeviceInput | Sequence[Signal | Tuple[Signal, ChannelStateInformation | None]], optional):
                Signal models fed to the receive operators.
                If not provided, the operatores are expected to have inputs cached

            cache (bool, optional):
                Cache the generated received information at the device's receive operators.
                Enabled by default.

        Returns: List of information generated by receiving over the device's operators.

        Raises:

            ValueError: If the number of operator inputs does not match the number of receive operators.
            RuntimeError: If no operator inputs were specified and an operator has no cached inputs.
        """

        _operator_inputs: Sequence[Tuple[Signal, ChannelStateInformation | None]]

        # Refer to the operator caches if no inputs were specified
        if operator_inputs is None:
            _operator_inputs = [(o.signal, o.csi) for o in self.receivers]

        # Convert object oriented input
        elif isinstance(operator_inputs, ProcessedDeviceInput):
            _operator_inputs = operator_inputs.operator_inputs

        else:
            _operator_inputs = operator_inputs

        if len(_operator_inputs) != self.receivers.num_operators:
            raise ValueError(f"Number of operator inputs ({len(_operator_inputs)}) does not match the number of receive operators ({self.receivers.num_operators})")

        # Generate receive information
        receptions: List[Reception] = []
        for operator, (signal, csi) in zip(self.receivers, _operator_inputs):
            reception = operator.receive(signal, csi, cache)
            receptions.append(reception)

        return receptions

    def receive(self, impinging_signals: DeviceInput | Signal | Sequence[Signal], cache: bool = True) -> DeviceReception:
        """Receive over this device.

        Internally calls :meth:`Device.process_input` and :meth:`Device.receive_operators`.

        Args:

            impinging_signals (Union[DeviceInput, Signal, Sequence[Signal]]):
                The samples to be processed by the device.

            cache (bool, optional):
                Cache the received information.
                Enabled by default.

        Returns: The received device information.
        """

        # Process input
        processed_input = self.process_input(impinging_signals)

        # Generate receptions
        receptions = self.receive_operators(processed_input.operator_inputs, cache)

        # Generate device reception
        return DeviceReception.From_ProcessedDeviceInput(processed_input, receptions)

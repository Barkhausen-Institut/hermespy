# -*- coding: utf-8 -*-
"""
===============
Device Modeling
===============

.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   classDiagram-v2

   direction RL

   class Device {

       topology
       carrier_frequency
       transmit()
       receive()
   }

   class SimulatedDevice {

       position
       orientation
       velocity
       acceleration
   }

   class HardwareDevice {

       trigger()
   }

   class Operator {

       transmit()
       receive()
   }

   class Modem {

       tx_bits
       rx_bits
       ...
       waveform
       transmit()
       receive()
   }

   class Radar {

       waveform
       ...
       target_estimates
       transmit()
       receive()
   }

   Operator <|-- Modem
   Operator <|-- Radar
   Device *-- Operator
   SimulatedDevice <|-- Device
   HardwareDevice <|-- Device


.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   flowchart LR

   channel{Real World}

   subgraph devicea[HardwareDevice]

       direction TB
       deviceatx>Tx Slot] --> deviceabinding[Hardware Binding] --> devicearx>Rx Slot]

   end

   subgraph deviceb[HardwareDevice]

       direction TB
       devicebtx>Tx Slot] --> devicebbinding[Hardware Binding] --> devicebrx>Rx Slot]
   end

   deviceabinding <--> channel
   devicebbinding <--> channel

.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   flowchart LR

   channel{Channel Modeling}

   subgraph devicea[SimulatedDevice]

       direction TB
       deviceatx>Tx Slot]
       devicearx>Rx Slot]

   end

   subgraph deviceb[SimulatedDevice]

       direction TB
       devicebtx>Tx Slot]
       devicebrx>Rx Slot]
   end

   deviceatx --> channel --> devicearx
   devicebtx --> channel --> devicebrx

"""

from __future__ import annotations
from abc import ABC, abstractmethod
from collections.abc import Sequence
from itertools import chain
from typing import Callable, Generic, Iterator, overload, Type, TypeVar
from typing_extensions import override

import numpy as np
from scipy.constants import speed_of_light

from .antennas import AntennaArray
from .factory import Serializable, SerializationProcess, DeserializationProcess
from .hooks import Hook, Hookable
from .precoding import (
    TransmitSignalCoding,
    TransmitStreamEncoder,
    ReceiveSignalCoding,
    ReceiveStreamDecoder,
)
from .random_node import RandomNode
from .signal_model import Signal
from .state import DeviceState, DST, ReceiveState, TransmitState
from .transformation import Transformable, Transformation

__author__ = "Jan Adler"
__copyright__ = "Copyright 2024, Barkhausen Institut gGmbH"
__credits__ = ["Jan Adler"]
__license__ = "AGPLv3"
__version__ = "1.5.0"
__maintainer__ = "Jan Adler"
__email__ = "jan.adler@barkhauseninstitut.org"
__status__ = "Prototype"


DSPType = TypeVar("DSPType")
"""Type of DSP algorithm."""


DeviceType = TypeVar("DeviceType", bound="Device")
"""Type of device."""


class DSPResult(Serializable):
    """Base class for results of digital signal processing algorithms."""

    signal: Signal
    """Base-band model of the processed signal."""

    def __init__(self, signal: Signal) -> None:
        """
        Args:

            signal:
                Base-band waveform model.
        """

        self.signal = signal

    def serialize(self, process: SerializationProcess) -> None:
        process.serialize_object(self.signal, "signal")

    @classmethod
    def Deserialize(cls: Type[DSPResult], process: DeserializationProcess) -> DSPResult:
        signal = process.deserialize_object("signal")
        return cls(signal)


class Transmission(DSPResult):
    """Information generated by transmitting over a transmit operator."""


class Reception(DSPResult):
    """Information generated by receiving over a receive operator."""


ReceptionType = TypeVar("ReceptionType", bound=Reception)
"""Type variable of a :class:`Reception`."""


class DeviceOutput(Serializable):
    """Base class for the output of a device."""

    __mixed_signal: Signal

    def __init__(self, mixed_signal: Signal) -> None:
        """
        Args:

            mixed_signal: Mixed signal emerging from the device.
        """

        self.__mixed_signal = mixed_signal

    @property
    def sampling_rate(self) -> float:
        """Sampling rate at which the device operates.


        Returns: Sampling rate in Hz.
        """

        return self.__mixed_signal.sampling_rate

    @property
    def num_antennas(self) -> int:
        """Number of transmitting device antennas.

        Returns: Number of antennas.
        """

        return self.__mixed_signal.num_streams

    @property
    def carrier_frequency(self) -> float:
        """Carrier frequency at which the device operates.

        Returns: Carrier frequency in Hz.
        """

        return self.__mixed_signal.carrier_frequency

    @property
    def emerging_signals(self) -> Sequence[Signal]:
        """Models of electromagnetic signals generated by the device.

        Returns: List of signal models.
        """

        return [self.__mixed_signal]

    @property
    def num_emerging_signals(self) -> int:
        """Number of emerging signal models.

        Returns: Count of models.
        """

        return len(self.emerging_signals)

    @property
    def mixed_signal(self) -> Signal:
        """Combined signal of the device's transmissions.

        Returns: Signal model of the device's electromagnetic transmission.
        """

        return self.__mixed_signal

    def serialize(self, process: SerializationProcess) -> None:
        process.serialize_object(self.mixed_signal, "mixed_signal")

    @classmethod
    def Deserialize(cls: Type[DeviceOutput], process: DeserializationProcess) -> DeviceOutput:
        mixed_signal = process.deserialize_object("mixed_signal")
        return cls(mixed_signal)


DTT = TypeVar("DTT", bound="DeviceTransmission")
"""Type of device transmission."""


class DeviceTransmission(DeviceOutput):
    """Information generated by transmitting over a device."""

    __dsp_transmissions: Sequence[Transmission]

    def __init__(self, dsp_transmissions: Sequence[Transmission], mixed_signal: Signal) -> None:
        """
        Args:

            dsp_transmissions: List of information generated by transmit operators.
            mixed_signal: Mixed signal transmitted by the device.
        """

        # Initialize base class
        DeviceOutput.__init__(self, mixed_signal)

        # Initialze class attributes
        self.__operator_transmissions = dsp_transmissions

    @classmethod
    def From_Output(
        cls: Type[DeviceTransmission],
        output: DeviceOutput,
        dsp_transmissions: Sequence[Transmission],
    ) -> DeviceTransmission:
        """Initialize a device transmission from a device output.

        Args:

            output: Device output object.
            dsp_transmissions: List of information generated by transmit operators.
        """

        return cls(dsp_transmissions, output.mixed_signal)

    @property
    def operator_transmissions(self) -> Sequence[Transmission]:
        """Information transmitted by device operators.

        Returns: Operator information.
        """

        return self.__operator_transmissions

    @property
    def num_operator_transmissions(self) -> int:
        """Number of operator transmissions."""

        return len(self.__operator_transmissions)

    def serialize(self, process: SerializationProcess) -> None:
        # Serialize base class
        DeviceOutput.serialize(self, process)

        # Serialize transmissions
        process.serialize_object_sequence(self.operator_transmissions, "dsp_transmissions")

    @classmethod
    def Deserialize(
        cls: Type[DeviceTransmission], process: DeserializationProcess
    ) -> DeviceTransmission:
        # Deserialize base class
        device_output = DeviceOutput.Deserialize(process)

        # Deserialize transmissions
        operator_transmissions = process.deserialize_object_sequence(
            "dsp_transmissions", Transmission
        )

        return cls.From_Output(device_output, operator_transmissions)


class DeviceInput(Serializable):
    """Receive information required by devices."""

    __impinging_signals: Sequence[Signal]

    def __init__(self, impinging_signals: Signal | Sequence[Signal]) -> None:
        """
        Args:

            impinging_signals: Signals to be processed by the device.
        """

        impinging_signals = (
            [impinging_signals] if isinstance(impinging_signals, Signal) else impinging_signals
        )
        self.__impinging_signals = impinging_signals

    @property
    def impinging_signals(self) -> Sequence[Signal]:
        """Signals to be processed by the device.

        Returns: List of signal models.
        """

        return self.__impinging_signals

    @property
    def num_impinging_signals(self) -> int:
        """Number of signals impinging onto the device.

        Returns: Signal model count.
        """

        return len(self.__impinging_signals)

    def serialize(self, process: SerializationProcess) -> None:
        process.serialize_object_sequence(self.impinging_signals, "impinging_signals")

    @classmethod
    def Deserialize(cls: Type[DeviceInput], process: DeserializationProcess) -> DeviceInput:
        impinging_signals = process.deserialize_object_sequence("impinging_signals", Signal)
        return cls(impinging_signals)


class ProcessedDeviceInput(DeviceInput):
    """Information generated by receiving over a device."""

    __operator_inputs: Sequence[Signal]

    def __init__(
        self,
        impinging_signals: DeviceInput | Signal | Sequence[Signal],
        operator_inputs: Sequence[Signal],
    ) -> None:
        """
        Args:

            impinging_signals:
                Numpy vector containing lists of signals impinging onto the device.

            operator_inputs:
                Signal models to be processed by receive DSP algorithms.
        """

        if isinstance(impinging_signals, DeviceInput):
            impinging_signals = impinging_signals.impinging_signals

        # Initialize base class
        DeviceInput.__init__(self, impinging_signals)

        # Initialize attributes
        self.__operator_inputs = operator_inputs

    @property
    def operator_inputs(self) -> Sequence[Signal]:
        return self.__operator_inputs

    @property
    def num_operator_inputs(self) -> int:
        """Number of operator inputs.

        Returns: Input count.
        """

        return len(self.__operator_inputs)

    def serialize(self, process: SerializationProcess) -> None:
        DeviceInput.serialize(self, process)
        process.serialize_object_sequence(self.operator_inputs, "operator_inputs")

    @classmethod
    def Deserialize(
        cls: Type[ProcessedDeviceInput], process: DeserializationProcess
    ) -> ProcessedDeviceInput:
        impinging_signals = process.deserialize_object_sequence("impinging_signals", Signal)
        operator_inputs = process.deserialize_object_sequence("operator_inputs", Signal)
        return cls(impinging_signals, operator_inputs)


DRT = TypeVar("DRT", bound="DeviceReception")
"""Type of device reception."""


class DeviceReception(ProcessedDeviceInput):
    """Information generated by receiving over a device and its operators."""

    __operator_receptions: Sequence[Reception]

    def __init__(
        self,
        impinging_signals: Signal | Sequence[Signal],
        operator_inputs: Sequence[Signal],
        operator_receptions: Sequence[Reception],
    ) -> None:
        """
        Args:

            impinging_signals:
                Numpy vector containing lists of signals impinging onto the device.

            operator_inputs:
                Signal models to be processed by receive DSP algorithms.

            operator_separation:
                Is the operator separation flag enabled?

            operator_receptions:
                Information inferred from receive operators.
        """

        # Initialize base class
        ProcessedDeviceInput.__init__(self, impinging_signals, operator_inputs)

        # Initialize attributes
        self.__operator_receptions = operator_receptions

    @classmethod
    def From_ProcessedDeviceInput(
        cls: Type[DRT], device_input: ProcessedDeviceInput, operator_receptions: Sequence[Reception]
    ) -> DRT:
        """Initialize an instance from a processed device input.

        Args:

            device_input:
                The processed device output.

            operator_receptions:
                List of operator receptions.

        Returns: The initialized object.
        """

        return cls(
            device_input.impinging_signals, device_input.operator_inputs, operator_receptions
        )

    @property
    def operator_receptions(self) -> Sequence[Reception]:
        """Information transmitted by device operators.

        Returns: Operator information.
        """

        return self.__operator_receptions

    @property
    def num_operator_receptions(self) -> int:
        """Number of operator receptions.

        Returns: Number of receptions.
        """

        return len(self.__operator_receptions)

    @override
    def serialize(self, process: SerializationProcess) -> None:
        ProcessedDeviceInput.serialize(self, process)
        process.serialize_object_sequence(self.operator_receptions, "dsp_receptions")

    @override
    @classmethod
    def Deserialize(cls, process: DeserializationProcess) -> DeviceReception:
        input = ProcessedDeviceInput.Deserialize(process)
        operator_receptions = process.deserialize_object_sequence("dsp_receptions", Reception)
        return cls.From_ProcessedDeviceInput(input, operator_receptions)


class MixingOperator(Serializable):
    """Base class for operators performing mixing operations."""

    __carrier_frequency: float | None  # Carrier frequency

    def __init__(self, carrier_frequency: float | None = None) -> None:
        """
        Args:

            carrier_frequency:
                Central frequency of the mixed signal in radio-frequency transmission band.
        """

        # Initialize base class
        Serializable.__init__(self)

        # Initialize class attributes
        self.carrier_frequency = carrier_frequency

    @property
    def carrier_frequency(self) -> float | None:
        """Central frequency of the mixed signal in radio-frequency transmission band in Hz.

        Denoted by :math:`f_c` with unit :math:`\\left[ f_c \\right] = \\mathrm{Hz} = \\tfrac{1}{\\mathrm{s}}` in the literature.
        If not specified, i.e. :py:obj:`None`, the operated device's default carrier frequency will be assumed
        during signal processing.

        Raises:
            ValueError: If the carrier frequency is smaller than zero.
        """

        return self.__carrier_frequency

    @carrier_frequency.setter
    def carrier_frequency(self, value: float | None) -> None:
        if value is None:
            self.__carrier_frequency = None
            return

        if value < 0.0:
            raise ValueError("Carrier frequency must be greater or equal to zero")

        self.__carrier_frequency = value

    @override
    def serialize(self, process: SerializationProcess) -> None:
        if self.carrier_frequency is not None:
            process.serialize_floating(self.carrier_frequency, "carrier_frequency")

    @classmethod
    def _DeserializeParameters(cls, process: DeserializationProcess) -> dict[str, object]:
        carrier_frequency = process.deserialize_floating("carrier_frequency", None)
        return {"carrier_frequency": carrier_frequency}

    @classmethod
    @override
    def Deserialize(cls: Type[MixingOperator], process: DeserializationProcess) -> MixingOperator:
        parameters = cls._DeserializeParameters(process)
        return cls(**parameters)  # type: ignore[arg-type]


class Receiver(Generic[ReceptionType], RandomNode, MixingOperator):
    """Operator receiving from a device."""

    __selected_receive_ports: Sequence[int] | None
    __receive_callbacks: Hookable[ReceptionType]

    def __init__(
        self,
        seed: int | None = None,
        selected_receive_ports: Sequence[int] | None = None,
        carrier_frequency: float | None = None,
    ) -> None:
        """
        Args:

            seed:
                Random seed used to initialize the pseudo-random number generator.

            selected_receive_ports:
                Indices of antenna ports selected for reception from the operated :class:`Device's<hermespy.core.device.Device>` antenna array.
                If not specified, all available antenna ports will be considered.

            carrier_frequency:
                Central frequency of the mixed signal in radio-frequency transmission band.
                If not specified, the operated device's default carrier frequency will be assumed during signal processing.
        """

        # Initialize base classes
        RandomNode.__init__(self, seed=seed)
        MixingOperator.__init__(self, carrier_frequency)

        # Initialize class attributes
        self.__receive_callbacks = Hookable()
        self.selected_receive_ports = selected_receive_ports

    def add_receive_callback(
        self, callback: Callable[[ReceptionType], None]
    ) -> Hook[ReceptionType]:
        """Add a callback to be called after processing the receive DSP algorithm.

        Args:

            callback:
                Function to be called after processing the receive DSP algorithm.
                The receive output is passed as the only argument.

        Returns: Hook to be used for removal.
        """

        return self.__receive_callbacks.add_callback(callback)

    @property
    def selected_receive_ports(self) -> Sequence[int] | None:
        """Indices of antenna ports selected for reception from the operated :class:`Device's<hermespy.core.device.Device>` antenna array.

        If :py:obj:`None`, all available antenna ports will be considered.
        """

        return self.__selected_receive_ports

    @selected_receive_ports.setter
    def selected_receive_ports(self, value: Sequence[int] | None) -> None:
        self.__selected_receive_ports = value

    def receive(self, signal: Signal, state: DeviceState, notify: bool = True) -> ReceptionType:
        """Process a received signal by the receiver.

        Wrapper around the abstract :meth:`_receive<._receive>` method.

        Args:

            signal:
                Model of the signal samples to be processed by the DSP algorithm.

            state:
                State of the receiving device to be conmsidered by the DSP algorithm.

            notify:
                Notify the receiver's callbacks.
                Enabled by default.

        Returns: Information received by this operator.

        Raises:

            ValueError: If the number of signal streams does not match the number of receive ports.
        """

        # Generate the state for this DSP algorithm's assigned ports
        receive_state = state.receive_state(self.selected_receive_ports)

        # Assert the number of signal streams
        if signal.num_streams != receive_state.num_receive_dsp_ports:
            raise ValueError(
                f"Number of signal streams does not match the number of receive ports ({signal.num_streams} != {receive_state.num_receive_dsp_ports})"
            )

        # Run the receive DSP routine
        reception = self._receive(signal, receive_state)

        # Notify the receiver's callbacks
        if notify:
            self.__receive_callbacks.notify(reception)

        # Return received information
        return reception

    @abstractmethod
    def _receive(self, signal: Signal, state: ReceiveState) -> ReceptionType:
        """Process a received signal by the receiver.

        Subroutine of the public :meth:`receive<hermespy.core.device.Receiver.receive>`
        method that performs the pipeline-specific receive processing
        and consolidates the inferred information into a single
        :class:`Reception<hermespy.core.device.Reception>` object.

        Args:
            signal: Multi-stream signal model to be processed.
            state: Device state to be considered during reception.

        Returns:
            Information inferred from the received signal.
        """
        ...  # pragma: no cover

    @property
    @abstractmethod
    def power(self) -> float:
        """Expected power of the received signal in Watts.

        .. note::
           Applies only to the signal-carrying parts of the transmission,
           silent parts shuch as guard intervals should not be considered.
        """
        ...  # pragma: no cover

    @abstractmethod
    def samples_per_frame(self, bandwidth: float, oversampling_factor: int) -> int:
        """Number of samples required to process at least a single frame.

        Args:
            bandwidth: The processed signal's bandwidth in Hz.
            oversampling_factor: Factor by which the processed signal is oversampled.

        Returns:
            Number of samples.
        """
        ...  # pragma: no cover

    @override
    def serialize(self, process: SerializationProcess) -> None:
        MixingOperator.serialize(self, process)
        if self.selected_receive_ports is not None:
            process.serialize_array(
                np.asarray(self.selected_receive_ports), "selected_receive_ports"
            )

    @classmethod
    @override
    def _DeserializeParameters(cls, process: DeserializationProcess) -> dict[str, object]:
        params = MixingOperator._DeserializeParameters(process)
        params["selected_receive_ports"] = process.deserialize_array(
            "selected_receive_ports", np.int64, None
        )  # type: ignore
        return params


class DSPSlot(Generic[DSPType], Sequence[DSPType]):
    """Slot for digital signal processing algorithms operating on a device."""

    __device: Device  # Device this operator belongs to
    __dsp_algorithms: list[DSPType]  # List of registered operators

    def __init__(self, device: Device) -> None:
        """
        Args:

            device: Device this slot belongs to.
        """

        self.__device = device
        self.__dsp_algorithms = []

    @property
    def device(self) -> Device:
        """Device this operator slot belongs to.

        Returns:
            Device: Handle to the device.
        """

        return self.__device

    def operator_index(self, operator: DSPType) -> int:
        """Index of an operator within this slot.

        Returns:
            index: The `operator`'s index.

        Raises:
            ValueError: If the `operator` is not registered at this slot.
        """

        return self.__dsp_algorithms.index(operator)

    def add(self, operator: DSPType) -> None:
        """Add a new operator to this slot.

        Args:
            operator:
                Operator to be added to this slot.

        Raises:
            RuntimeError: If the `operator` is already registered at this slot.
        """

        # Do nothing if the operator is already registered
        if operator in self.__dsp_algorithms:
            return

        self.__dsp_algorithms.append(operator)

    def remove(self, operator: DSPType) -> None:
        """Remove an operator from this slot.

        Args:
            operator:
                Handle to the operator to be removed.
        """

        if operator in self.__dsp_algorithms:
            self.__dsp_algorithms.remove(operator)

    def registered(self, operator: DSPType) -> bool:
        """Check if an operator is registered at this slot.

        Returns:
            bool: Boolean indicating the registration status.
        """

        return operator in self.__dsp_algorithms

    @property
    def num_operators(self) -> int:
        """Number of operators on this slot.

        Returns:
            int: Number of operators.
        """

        return len(self.__dsp_algorithms)

    @overload
    def __getitem__(self, item: int) -> DSPType: ...  # pragma:  no cover

    @overload
    def __getitem__(self, item: slice) -> Sequence[DSPType]: ...  # pragma: no cover

    def __getitem__(self, item: int | slice) -> DSPType | Sequence[DSPType]:
        return self.__dsp_algorithms[item]

    def __iter__(self) -> Iterator[DSPType]:
        """Iterating over operator slots returns the iterator over the slots."""

        return self.__dsp_algorithms.__iter__()

    def __contains__(self, operator: object) -> bool:
        """Contains is just a convenient mask for registered.

        Returns: Registration indicator.
        """

        return operator in self.__dsp_algorithms

    def __len__(self) -> int:
        return self.num_operators


TransmissionType = TypeVar("TransmissionType", bound="Transmission")
"""Type variable of a :class:`Transmission`."""


class Transmitter(Generic[TransmissionType], RandomNode, MixingOperator):
    """Operator transmitting over a device."""

    __transmit_callbacks: Hookable[TransmissionType]
    __selected_transmit_ports: Sequence[int] | None

    def __init__(
        self,
        seed: int | None = None,
        selected_transmit_ports: Sequence[int] | None = None,
        carrier_frequency: float | None = None,
    ) -> None:
        """
        Args:

            seed:
                Random seed used to initialize the pseudo-random number generator.

            selected_transmit_ports:
                Indices of antenna ports selected for transmission from the operated :class:`Device's<hermespy.core.device.Device>` antenna array.
                If not specified, all available ports will be considered.

            carrier_frequency:
                Central frequency of the mixed signal in radio-frequency transmission band.
                If not specified, the operated device's default carrier frequency will be assumed during signal processing.
        """

        # Initialize operator base class
        RandomNode.__init__(self, seed=seed)
        MixingOperator.__init__(self, carrier_frequency)

        # Initialize class attributes
        self.__transmit_callbacks = Hookable()
        self.__selected_transmit_ports = selected_transmit_ports

    def add_transmit_callback(
        self, callback: Callable[[TransmissionType], None]
    ) -> Hook[TransmissionType]:
        """Add a callback to be called after processing the transmit DSP algorithm.

        Args:

            callback:
                Function to be called after processing the transmit DSP algorithm.
                The transmit output is passed as the only argument.

        Returns: Hook to be used for removal.
        """

        return self.__transmit_callbacks.add_callback(callback)

    def notify_transmit_callbacks(self, transmission: TransmissionType) -> None:
        """Notify the registered callbacks about the generated transmission.

        Args:

            transmission:
                Transmission to be passed to the callbacks.
        """

        self.__transmit_callbacks.notify(transmission)

    def transmit(
        self, state: DeviceState, duration: float = 0.0, notify: bool = True
    ) -> TransmissionType:
        """Transmit a signal.

        Registers the signal samples to be transmitted by the underlying device.

        Wrapper around the abstract :meth:`_transmit<Transmitter._transmit>` method.

        Args:

            state:
                State of the device at the time of transmission.
                If not specified, the device's current state will be queried by calling :meth:`hermespy.core.device.Device.state`.

            duration:
                Duration of the transmitted signal.
                If not specified, i.e. zero, the duration will be inferred by the transmitter.

            notify:
                Notify the transmitter's callbacks about the generated transmission.

        Returns:

            Information generated while transmitting over this operator.

        Raises:

            FloatingError: If the transmitter is currently considered floating.
        """

        # Generate the state for this DSP algorithm's assigned ports
        # Run the transmit DSP routine
        transmission = self._transmit(state.transmit_state(self.selected_transmit_ports), duration)

        # Notify the registered callbacks if the respective flag is enabled
        if notify:
            self.notify_transmit_callbacks(transmission)

        return transmission

    @abstractmethod
    def _transmit(self, state: TransmitState, duration: float) -> TransmissionType:
        """Generate information to be transmitted.

        Subroutine of the public :meth:`transmit<hermespy.core.device.Transmitter.transmit>` method that performs the pipeline-specific transmit-processing
        and consolidates the generated information into a single :class:`hermespy.core.device.Transmission` object.

        Args:

            state:
                State of the device at the time of transmission.

            duration:
                Duration of the transmitted signal in seconds.
                If not specified, the duration of a single frame will be assumed.

        Returns: Information to be transmitted.
        """
        ...  # pragma: no cover

    @property
    @abstractmethod
    def power(self) -> float:
        """Expected power of the transmitted signal in Watts.

        .. note::
           Applies only to the signal-carrying parts of the transmission,
           silent parts shuch as guard intervals should not be considered.
        """
        ...  # pragma: no cover

    @property
    def selected_transmit_ports(self) -> Sequence[int] | None:
        """Indices of antenna ports selected for transmission from the operated :class:`Device's<hermespy.core.device.Device>` antenna array.

        If :py:obj:`None`, all available transmit ports will be considered.
        """

        return self.__selected_transmit_ports

    @selected_transmit_ports.setter
    def selected_transmit_ports(self, value: Sequence[int] | None) -> None:
        self.__selected_transmit_ports = value

    @override
    def serialize(self, process: SerializationProcess) -> None:
        MixingOperator.serialize(self, process)
        if self.selected_transmit_ports is not None:
            process.serialize_array(
                np.asarray(self.selected_transmit_ports), "selected_transmit_ports"
            )

    @classmethod
    @override
    def _DeserializeParameters(cls, process: DeserializationProcess) -> dict[str, object]:
        params = MixingOperator._DeserializeParameters(process)
        params["selected_transmit_ports"] = process.deserialize_array(
            "selected_transmit_ports", np.int64, None
        )
        return params


class TransmitterSlot(DSPSlot[Transmitter]):
    """Slot for transmitting operators within devices."""

    ...  # pragma: no cover


class ReceiverSlot(DSPSlot[Receiver]):
    """Slot for receiving operators within devices."""

    def min_num_samples_per_frame(self, bandwidth: float, oversampling_factor: int) -> int:
        """Query the number of samples required to process at least a single frame for each DSP algorithm.

        Args:
            bandwidth: The processed signal's bandwidth in Hz.
            oversampling_factor: Factor by which the processed signal is oversampled.

        Returns:
            Number of samples.
        """

        samples_per_frame = 0
        dsp: Receiver
        for dsp in self:
            samples_per_frame = max(
                samples_per_frame, dsp.samples_per_frame(bandwidth, oversampling_factor)
            )

        return samples_per_frame


class UnsupportedSlot(DSPSlot):
    """Slot for unsupported operations within devices."""

    def add(self, operator: object) -> None:
        raise RuntimeError("Slot not supported by this device")


class Device(ABC, Generic[DST], Transformable, RandomNode, Serializable):
    """Physical device representation within HermesPy.

    It acts as the basis for all transmissions and receptions of sampled electromagnetic signals.
    """

    _DEFAULT_POWER: float = 1.0

    transmitters: TransmitterSlot
    """Transmitters broadcasting signals over this device."""

    receivers: ReceiverSlot
    """Receivers capturing signals from this device"""

    __transmit_coding: TransmitSignalCoding  # Codings applied to transmitted samples before upload
    __receive_coding: (
        ReceiveSignalCoding  # Codings applied to received samples directly after download
    )
    __power: float  # Average power of the transmitted signals
    __output_callbacks: Hookable[DeviceOutput]  # Callbacks notified about generated outputs
    __input_callbacks: Hookable[ProcessedDeviceInput]  # Callbacks notified about processed inputs

    def __init__(
        self,
        transmit_dsp: Transmitter | Sequence[Transmitter] | None = None,
        receive_dsp: Receiver | Sequence[Receiver] | None = None,
        transmit_encoding: (
            TransmitSignalCoding | Sequence[TransmitStreamEncoder] | TransmitStreamEncoder | None
        ) = None,
        receive_decoding: (
            ReceiveSignalCoding | Sequence[ReceiveStreamDecoder] | ReceiveStreamDecoder | None
        ) = None,
        power: float = _DEFAULT_POWER,
        pose: Transformation | None = None,
        seed: int | None = None,
    ) -> None:
        """
        Args:

            transmit_dsp:
                Digital transmit signal processing algorithms operating on this device.

            receive_dsp:
                Digital receive signal processing algorithms operating on this device.

            transmit_encdoding:
                Digital coding applied to transmitted samples before digital-to-analog conversion.

            receive_decoding:
                Digital coding applied to received samples after analog-to-digital conversion.

            power:
                Average power of the transmitted signals in Watts.
                1.0 Watt by default.

            pose:
                Pose of the device with respect to its scenario coordinate system origin.

            seed:
                Random seed used to initialize the pseudo-random number generator.
        """

        # Initialize base classes
        RandomNode.__init__(self, None, seed)
        Transformable.__init__(self, pose)

        # Initialize transmit DSP layer
        self.transmitters = TransmitterSlot(self)
        if transmit_dsp is not None:
            _tx_dsps = [transmit_dsp] if isinstance(transmit_dsp, Transmitter) else transmit_dsp
            for tx_dsp in _tx_dsps:
                self.transmitters.add(tx_dsp)

        # Initialize receive DSP layer
        self.receivers = ReceiverSlot(self)
        if receive_dsp is not None:
            _rx_dsps = [receive_dsp] if isinstance(receive_dsp, Receiver) else receive_dsp
            for rx_dsp in _rx_dsps:
                self.receivers.add(rx_dsp)

        # Initialize digital transmit precoding layer
        self.__transmit_coding = TransmitSignalCoding()
        if transmit_encoding is not None:
            _tx_encoders = (
                [transmit_encoding]
                if isinstance(transmit_encoding, TransmitStreamEncoder)
                else transmit_encoding
            )
            for encoder in _tx_encoders:
                self.__transmit_coding[-1] = encoder

        # Initialize digital receive decoding layer
        self.__receive_coding = ReceiveSignalCoding()
        if receive_decoding is not None:
            _rx_decoders = (
                [receive_decoding]
                if isinstance(receive_decoding, ReceiveStreamDecoder)
                else receive_decoding
            )
            for decoder in _rx_decoders:
                self.__receive_coding[-1] = decoder

        # Initialize other various class attributes
        self.__input_callbacks = Hookable()
        self.__output_callbacks = Hookable()
        self.power = power

    @abstractmethod
    def state(self) -> DST:
        """Query the immutable physical state of the device.

        Returns: The physical device state.
        """
        ...  # pragma: no cover

    @property
    @abstractmethod
    def antennas(self) -> AntennaArray:
        """Model of the device's antenna array."""
        ...  # pragma: no cover

    @property
    def transmit_coding(self) -> TransmitSignalCoding:
        """Digital coding applied to transmitted samples before digital-to-analog conversion."""

        return self.__transmit_coding

    @property
    def receive_coding(self) -> ReceiveSignalCoding:
        """Digital coding applied to received samples after analog-to-digital conversion."""

        return self.__receive_coding

    @property
    def output_callbacks(self) -> Hookable[DeviceOutput]:
        """Callbacks notified about generated outputs."""

        return self.__output_callbacks

    @property
    def input_callbacks(self) -> Hookable[ProcessedDeviceInput]:
        """Callbacks notified about processed inputs."""

        return self.__input_callbacks

    @property
    def num_transmit_dsp_ports(self) -> int:
        """Number of available transmit ports for digital signal processing algorithms.

        If not transmit coding was configured, this value is equal to :attr:`~.num_transmit_rf_ports`.
        """

        return self.__transmit_coding.num_transmit_input_streams(self.num_transmit_rf_ports)

    @property
    def num_receive_dsp_ports(self) -> int:
        """Number of available receive ports for digital signal processing algorithms.

        If no receive coding was configured, this value is equal to :attr:`~.num_receive_rf_ports`.
        """

        return self.__receive_coding.num_receive_output_streams(self.num_receive_rf_ports)

    @property
    def num_transmit_rf_ports(self) -> int:
        """Number of available transmit RF ports connecting the device's digital and analog front-ends."""

        return self.antennas.num_transmit_antennas

    @property
    def num_receive_rf_ports(self) -> int:
        """Number of available receive antenna ports connecting the device's analog and digital front-ends."""

        return self.antennas.num_receive_antennas

    @property
    def num_transmit_antennas(self) -> int:
        """Number of available transmit antennas.

        Shorthand to :attr:`antennas'<antennas>` :meth:`num_transmit_antennas<hermespy.core.antennas.AntennaArrayBase.num_transmit_antennas>`.
        """

        return self.antennas.num_transmit_antennas

    @property
    def num_receive_antennas(self) -> int:
        """Number of available receive antennas.

        Shorthand to :attr:`antennas'<antennas>` :meth:`num_receive_antennas<hermespy.core.antennas.AntennaArrayBase.num_receive_antennas>`.
        """

        return self.antennas.num_receive_antennas

    @property
    def power(self) -> float:
        """Average power of the transmitted signal signal in :math:`\\mathrm{V}^2`.

        Raises:
            ValueError: If `value` is smaller than zero.
        """

        return self.__power

    @power.setter
    def power(self, value: float) -> None:
        if value < 0.0:
            raise ValueError("Average signal power must be greater or equal to zero")

        self.__power = value

    @property
    def snr(self) -> float:
        """Signal to noise ratio of the received signal."""

        # By default, we have no knowledge about the snr and assum no noise
        return float("inf")

    @property
    def num_antennas(self) -> int:
        """Number of antennas within this device's topology."""

        return self.antennas.num_antennas

    @property
    def max_frame_duration(self) -> float:
        """Maximum frame duration transmitted by this device."""

        max_duration = 0.0

        for operator in chain(self.transmitters, self.receivers):
            max_duration = max(max_duration, operator.frame_duration(self.bandwidth))  # type: ignore

        return max_duration

    @property
    @abstractmethod
    def carrier_frequency(self) -> float:
        """Central frequency of the device's emissions in the RF-band.

        Denoted by :math:`f_c` with unit :math:`\\left[ f_c \\right] = \\mathrm{Hz} = \\tfrac{1}{\\mathrm{s}}` in the literature.

        Raises:
            ValueError: On negative carrier frequencies.
        """
        ...  # pragma: no cover

    @property
    def wavelength(self) -> float:
        """Central wavelength of the device's emmissions in the RF-band in m.

        Denoted by :math:`\\lambda` with unit :math:`\\left[ \\lambda \\right] = \\mathrm{m}` in the literature.
        Related to the carrier frequency by the speed of light :math:`c` so that :math:`\\lambda = \\frac{c}{f_c}`.

        Raises:
            ValueError: On wavelengths smaller or equal to zero.
        """

        return speed_of_light / self.carrier_frequency

    @property
    @abstractmethod
    def sampling_rate(self) -> float:
        """Sampling rate at which the device's analog-to-digital converters operate in Hz.

        Raises:
            ValueError: If the sampling rate is not greater than zero.
        """
        ...  # pragma: no cover

    def add_dsp(self, dsp: Transmitter | Receiver) -> None:
        """Add a DSP algorithm to this device.

        Args:

            dsp:
                DSP algorithm to be added to the device.
                If the DSP algorithm is a transmitter, it will be added to the transmit layer.
                If the DSP algorithm is a receiver, it will be added to the receive layer.
                If the DSP is both, it will be added to both layers.
        """

        if isinstance(dsp, Transmitter):
            self.transmitters.add(dsp)

        if isinstance(dsp, Receiver):
            self.receivers.add(dsp)

    def transmit_operators(
        self, state: DST | None = None, notify: bool = True
    ) -> list[Transmission]:
        """Generate transmitted information for all registered operators.

        Calls :meth:`Transmitter.transmit` for each transmit operator.

        Args:

            state:
                Device state to be used for the transmission.
                If not provided, query the current device state by calling :meth:`state`.

            notify:
                Notify the transmitter's callbacks about the generated transmission.
                Enabled by default.

        Returns: List of operator transmisisons.
        """

        _state = self.state() if state is None else state
        return [transmitter.transmit(_state, 0.0, notify) for transmitter in self.transmitters]

    def generate_output(
        self,
        operator_transmissions: Sequence[Transmission],
        state: DST | None = None,
        resample: bool = True,
    ) -> DeviceOutput:
        """Generate the device's output.

        Args:
            operator_transmissions:
                List of operator transmissions from which to generate the output.
            state:
                Device state to be used for the output generation.
                If not provided, query the current device state
            resample:
                Resample the output signal to the device's sampling rate.
                Enabled by default.

        Returns:
            The device's output.

        Raises:

            RuntimeError: If the transmit coding is incompatible with the number of transmit antenna ports.
        """

        _state = self.state() if state is None else state

        # Ensure that the precoded signal will match the number of antenna ports
        required_num_dsp_streams = self.transmit_coding.num_transmit_input_streams(
            self.num_transmit_rf_ports
        )
        if _state.num_transmit_dsp_ports != required_num_dsp_streams:
            raise RuntimeError(
                f"Number of streams after transmit coding does not match the number of transmit antenna ports ({_state.num_transmit_dsp_ports} != {required_num_dsp_streams})"
            )

        # Query the intended transmission ports of each operator
        operator_streams = [o.selected_transmit_ports for o in self.transmitters]

        # Superimpose the operator transmissions to the device's RF configuration
        superimposed_signal = Signal.Empty(
            _state.sampling_rate,
            self.num_transmit_dsp_ports,
            carrier_frequency=_state.carrier_frequency,
        )

        for transmission, indices in zip(operator_transmissions, operator_streams):
            if transmission is not None:
                superimposed_signal = superimposed_signal.superimpose(
                    transmission.signal, resample=resample, stream_indices=indices
                )

        # Apply the transmit coding
        encoded_signal = self.transmit_coding.encode_streams(
            superimposed_signal, _state.transmit_state(list(range(self.num_transmit_antennas)))
        )

        # Generate the output
        output = DeviceOutput(encoded_signal)

        # Notify the output callbacks
        self.__output_callbacks.notify(output)

        return output

    def transmit(self, state: DST | None = None, notify: bool = True) -> DeviceTransmission:
        """Transmit over this device.

        Args:

            state:
                Device state to be used for the transmission.
                If not provided, query the current device state by calling :meth:`state<hermespy.core.device.Device.state>`.

            notify:
                Notify the transmitter's callbacks about the generated transmission.
                Enabled by default.

        Returns: Information transmitted by this device.
        """

        _state = self.state() if state is None else state
        operator_transmissions = self.transmit_operators(_state, notify)
        device_output = self.generate_output(operator_transmissions, _state)

        return DeviceTransmission.From_Output(device_output, operator_transmissions)

    def process_input(
        self, impinging_signals: DeviceInput | Signal | Sequence[Signal], state: DST | None = None
    ) -> ProcessedDeviceInput:
        """Process input signals impinging onto this device.

        Args:

            impinging_signals:
                The samples to be processed by the device.

            state:
                Device state to be used for the processing.
                If not provided, query the current device state.

        Returns: The processed device input information.

        Raises:

            ValueError: If the number of signal streams does not match the device configuration expectations.
        """

        # Query the current device state if none was provided
        _state = self.state() if state is None else state

        # Convert argument
        impinging_signals = (
            [impinging_signals] if isinstance(impinging_signals, Signal) else impinging_signals
        )
        impinging_signals = (
            impinging_signals.impinging_signals
            if isinstance(impinging_signals, DeviceInput)
            else impinging_signals
        )

        # Superimpose the impinging signal models
        if len(impinging_signals) != 1:
            superimposed_signal = Signal.Empty(
                self.sampling_rate,
                self.antennas.num_receive_antennas,
                carrier_frequency=self.carrier_frequency,
            )
            for signal in impinging_signals:
                superimposed_signal.superimpose(signal)

        else:
            superimposed_signal = impinging_signals[0]

        # Ensure that the number of antenna streams to be decoded matches the number of receive antenna ports
        if superimposed_signal.num_streams != self.num_receive_rf_ports:
            raise RuntimeError(
                f"Number of antenna streams does not match the required number of receive coding streams ({superimposed_signal.num_streams} != {self.num_receive_rf_ports})"
            )

        # Apply the receive coding
        decoded_signal = self.receive_coding.decode_streams(
            superimposed_signal, _state.receive_state()
        )

        # Each operator is fed the decoded signal by default
        operator_inputs: list[Signal] = []
        for receiver in self.receivers:
            selected_receive_antennas = receiver.selected_receive_ports
            stream_selector = (
                slice(None) if selected_receive_antennas is None else selected_receive_antennas
            )  # type: slice | Sequence[int]
            operator_inputs.append(decoded_signal[stream_selector, :])

        # Generate the input
        input = ProcessedDeviceInput(impinging_signals, operator_inputs)

        # Notify the input callbacks
        self.__input_callbacks.notify(input)

        return input

    def receive_operators(
        self,
        operator_inputs: ProcessedDeviceInput | Sequence[Signal],
        state: DST | None = None,
        notify: bool = True,
    ) -> list[Reception]:
        """Receive over the registered operators.

        Args:

            operator_inputs:
                The signal samples to be processed by the device's operators.
                If a :class:`ProcessedDeviceInput` is provided, the operator inputs will be extracted from it.
                Otherwise, the operator inputs are assumed to be provided directly.

            state:
                Assumed state of the device during reception.
                If not provided, the current device state will be queried by calling :meth:`state`.

            notfiy:
                Notify all registered callbacks within the involved DSP algorithms.
                Enabled by default.

        Returns: List of information generated by receiving over the device's operators.

        Raises:

            ValueError: If the number of operator inputs does not match the number of receive operators.
        """

        _operator_inputs = (
            operator_inputs.operator_inputs
            if isinstance(operator_inputs, ProcessedDeviceInput)
            else operator_inputs
        )
        _state = self.state() if state is None else state

        if len(_operator_inputs) != self.receivers.num_operators:
            raise ValueError(
                f"Number of operator inputs ({len(_operator_inputs)}) does not match the number of receive operators ({self.receivers.num_operators})"
            )

        # Generate receive information
        receptions: list[Reception] = []
        for operator, signal in zip(self.receivers, _operator_inputs):
            receptions.append(operator.receive(signal, _state, notify))

        return receptions

    def receive(
        self,
        impinging_signals: DeviceInput | Signal | Sequence[Signal],
        state: DST | None = None,
        notify: bool = True,
    ) -> DeviceReception:
        """Receive over this device.

        Internally calls :meth:`Device.process_input` and :meth:`Device.receive_operators`.

        Args:

            impinging_signals:
                The samples to be processed by the device.

            state:
                Device state to be used for the processing.
                If not provided, query the current device state by calling :meth:`state<hermespy.core.device.Device.state>`.

            notify:
                Notify all registered callbacks within the involved DSP algorithms.
                Enabled by default.

        Returns: The received device information.
        """

        _state = self.state() if state is None else state

        # Process input
        processed_input = self.process_input(impinging_signals, _state)

        # Generate receptions
        receptions = self.receive_operators(processed_input.operator_inputs, _state, notify)

        # Generate device reception
        return DeviceReception.From_ProcessedDeviceInput(processed_input, receptions)

    @override
    def serialize(self, process: SerializationProcess) -> None:
        process.serialize_object_sequence(self.transmitters, "transmit_dsp")
        process.serialize_object_sequence(self.receivers, "receive_dsp")
        process.serialize_object_sequence(self.transmit_coding, "transmit_encoding")
        process.serialize_object_sequence(self.receive_coding, "receive_decoding")
        process.serialize_floating(self.power, "power")
        process.serialize_object(self.pose, "pose")

    @classmethod
    def _DeserializeParameters(cls, process: DeserializationProcess) -> dict[str, object]:
        return {
            "transmit_dsp": process.deserialize_object_sequence("transmit_dsp", Transmitter),
            "receive_dsp": process.deserialize_object_sequence("receive_dsp", Receiver),
            "transmit_encoding": process.deserialize_object_sequence(
                "transmit_encoding", TransmitStreamEncoder
            ),
            "receive_decoding": process.deserialize_object_sequence(
                "receive_decoding", ReceiveStreamDecoder
            ),
            "power": process.deserialize_floating("power", cls._DEFAULT_POWER),
            "pose": process.deserialize_object("pose", Transformation, None),
        }

    @classmethod
    @override
    def Deserialize(cls: Type[DeviceType], process: DeserializationProcess) -> DeviceType:
        parameters = cls._DeserializeParameters(process)
        return cls(**parameters)  # type: ignore[arg-type]

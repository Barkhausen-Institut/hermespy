# -*- coding: utf-8 -*-

from __future__ import annotations
from typing import Set, Any
from typing_extensions import override
from math import ceil

import numpy as np

import sionna.rt as rt  # type: ignore

from hermespy.channel.channel import ChannelSampleHook, InterpolationMode, LinkState
from hermespy.core import (
    ChannelStateInformation,
    ChannelStateFormat,
    DeserializationProcess,
    SerializationProcess,
    SignalBlock,
)
from .channel import Channel, ChannelRealization, ChannelSample

__author__ = "Egor Achkasov"
__copyright__ = "Copyright 2024, Barkhausen Institut gGmbH"
__credits__ = ["Egor Achkasov"]
__license__ = "AGPLv3"
__version__ = "1.5.0"
__maintainer__ = "Jan Adler"
__email__ = "jan.adler@barkhauseninstitut.org"
__status__ = "Prototype"


class SionnaRTChannelSample(ChannelSample):
    """Sample of a Sionna RT channel realization.

    Generated by sampling a :class:`SionnaRTChannelRealization`.
    """

    paths: rt.Paths

    # Channel states and delays before Doppler effect application.
    # These members are Tensorflow tensors and SHOULD NOT be used directly.
    # It is a backup of sionna-rt.Paths properties used to reverse Doppler effect.
    __a: Any
    _tau: Any

    __gain: float

    def __init__(self, paths: rt.Paths, gain: float, state: LinkState) -> None:
        """
        Args:

           paths:
                Ray-Tracing paths in this sample. Should be generated with _realize of Realization.

           gain:
                Linear channel power factor.

           state:
                State of the channel at the time of sampling.
        """

        # Initialize base class
        ChannelSample.__init__(self, state)

        # Initialize class attributes
        self.paths = paths
        self.__a = paths.a
        self._tau = paths._tau
        self.__gain = gain

    @property
    def expected_energy_scale(self) -> float:
        """Expected linear scaling of a propagated signal's energy at each receiving antenna.

        Required to compute the expected energy of a signal after propagation,
        and therfore signal-to-noise ratios (SNRs) and signal-to-interference-plus-noise ratios (SINRs).

        TODO Current implementation is technically incorrect.
        """

        return np.abs(np.sum(self.__a))

    @override
    def state(
        self,
        num_samples: int,
        max_num_taps: int,
        interpolation_mode: InterpolationMode = InterpolationMode.NEAREST,
    ) -> ChannelStateInformation:

        # Apply Doppler effect and get the channel impulse response
        # the cir() method applied doppler internally
        a, tau = self.paths.cir(
            sampling_frequency=self.bandwidth,
            num_time_steps=num_samples,
            normalize_delays=False,
            out_type="numpy",
        )
        # Extract and reshape the path properties as needed
        a = a[0, :, 0, :, :, :]
        tau = tau[0, 0, :]

        # Init result

        max_delay = np.max(tau) if np.size(tau) != 0 else 0
        max_delay_in_samples = min(max_num_taps, ceil(max_delay * self.bandwidth))
        raw_state = np.zeros(
            (
                self.num_receive_antennas,
                self.num_transmit_antennas,
                num_samples,
                1 + max_delay_in_samples,
            ),
            dtype=np.complex128,
        )
        # If no paths hit the target, then return an empty state
        if np.size(a) == 0 or np.size(tau) == 0:
            return ChannelStateInformation(ChannelStateFormat.IMPULSE_RESPONSE, raw_state)

        for a_p, tau_p in zip(np.moveaxis(a, -2, 0), np.moveaxis(tau, -1, 0)):
            if tau_p < 0:
                continue
            delay_tap_index = int(tau_p * self.bandwidth)
            if delay_tap_index >= max_num_taps:
                continue  # pragma: no cover

            raw_state[:, :, :, delay_tap_index] += a_p

        raw_state *= np.sqrt(self.__gain)
        return ChannelStateInformation(ChannelStateFormat.IMPULSE_RESPONSE, raw_state)

    @override
    def _propagate(
        self, signal_block: SignalBlock, interpolation: InterpolationMode
    ) -> SignalBlock:
        # Calculate the resulting signal block parameters
        sr_ratio = self.receiver_state.sampling_rate / self.transmitter_state.sampling_rate
        offset_new = int(signal_block.offset * sr_ratio)
        num_streams_new = self.num_receive_antennas
        num_samples_new = int(signal_block.num_samples * sr_ratio)

        # Apply Doppler effect and get the channel impulse response
        # the cir() method applied doppler internally
        a, tau = self.paths.cir(
            sampling_frequency=self.bandwidth,
            num_time_steps=signal_block.num_samples,
            normalize_delays=False,
            out_type="numpy",
        )
        # Extract and reshape as needed
        a = a[0, :, 0, :, :, :]
        tau = tau[0, 0, :]
        # If no paths hit the target, then return a zeroed signal
        if np.size(a) == 0 or np.size(tau) == 0:
            return SignalBlock(
                np.zeros((num_streams_new, num_samples_new), signal_block.dtype), offset_new
            )

        # Set other attributes
        max_delay = np.max(tau)
        max_delay_in_samples = ceil(max_delay * self.bandwidth)
        propagated_samples = np.zeros(
            (num_streams_new, signal_block.num_samples + max_delay_in_samples),
            dtype=signal_block.dtype,
        )

        # Prepare the optimal einsum path ahead of time for faster execution
        einsum_subscripts = "ijk,jk->ik"
        einsum_path = np.einsum_path(
            einsum_subscripts, a[:, :, 0, :], signal_block, optimize="optimal"
        )[0]

        # For each path
        for a_p, tau_p in zip(np.moveaxis(a, -2, 0), np.moveaxis(tau, -1, 0)):
            if tau_p == -1.0:
                continue
            t = int(tau_p * self.bandwidth)
            propagated_samples[:, t : t + signal_block.num_samples] += np.einsum(
                einsum_subscripts, a_p, signal_block, optimize=einsum_path
            )

        propagated_samples *= np.sqrt(self.__gain)
        return SignalBlock(propagated_samples, offset_new)


class SionnaRTChannelRealization(ChannelRealization[SionnaRTChannelSample]):
    """Realization of a Sionna RT channel.

    Generated by the :meth:`_realize()<SionnaRTChannel._realize>` routine of :class:`SionnaRTChannels<SionnaRTChannel>`.
    """

    __scene: rt.Scene
    __scene_file: str

    def __init__(
        self,
        scene: rt.Scene,
        scene_file: str,
        sample_hooks: Set[ChannelSampleHook] | None = None,
        gain: float = ChannelRealization._DEFAULT_GAIN,
    ) -> None:
        """
        Args:
            scene: The loaded scene object.
            scene_file:
                Path to the scene file.
                Required for simple serialization.
            sample_hooks: Hooks to be called when a new sample is generated.
            gain:
                Linear channel power gain factor.
                Defaults to 1.0.
        """

        ChannelRealization.__init__(self, sample_hooks, gain)
        self.__scene = scene
        self.__scene_file = scene_file

    @property
    def scene(self) -> rt.Scene:
        """Sionna scene object used to generate samples."""

        return self.__scene

    @override
    def _sample(self, state: LinkState) -> SionnaRTChannelSample:
        # Clear the scene
        self.__scene._transmitters.clear()
        self.__scene._receivers.clear()
        self.__scene._tx_array = None
        self.__scene._rx_array = None

        # init self.scene.tx_array
        self.__scene.tx_array = rt.PlanarArray(
            num_rows=1, num_cols=1, horizontal_spacing=0.5, pattern="iso", polarization="V"
        )

        # init self.scene.rx_array
        self.__scene.rx_array = rt.PlanarArray(
            num_rows=1, num_cols=1, horizontal_spacing=0.5, pattern="iso", polarization="V"
        )

        # init tx and rx
        self.__scene.add(rt.Transmitter("Alpha device", state.transmitter.position))
        self.__scene.add(rt.Receiver("Beta device", state.receiver.position))

        # set other self.scene params
        self.__scene.frequency = state.transmitter.carrier_frequency

        # calculate paths
        p_solver = rt.PathSolver()
        paths = p_solver(
            scene=self.__scene,
            max_depth=5,
            los=True,
            specular_reflection=True,
            diffuse_reflection=False,
            refraction=True,
            synthetic_array=True,
            seed=41,
        )

        # construct the sample
        return SionnaRTChannelSample(paths, self.gain, state)

    @override
    def _reciprocal_sample(
        self, sample: SionnaRTChannelSample, state: LinkState
    ) -> SionnaRTChannelSample:
        return self._sample(state)

    @override
    def serialize(self, process: SerializationProcess) -> None:
        ChannelRealization.serialize(self, process)
        process.serialize_string(self.__scene_file, "scene")

    @classmethod
    @override
    def Deserialize(cls, process: DeserializationProcess) -> SionnaRTChannelRealization:
        return cls(
            rt.load_scene(process.deserialize_string("scene")),
            process.deserialize_string("scene"),
            **ChannelRealization._DeserializeParameters(process),  # type: ignore[arg-type]
        )


class SionnaRTChannel(Channel[SionnaRTChannelRealization, SionnaRTChannelSample]):
    """Sionna ray-tracing channel.

    Refer to :doc:`/api/channel/sionna-rt` for further information.
    """

    __scene_file: str
    __scene: rt.Scene

    def __init__(
        self, scene: str, gain: float = Channel._DEFAULT_GAIN, seed: int | None = None
    ) -> None:
        """
        Args:
            scene: Path to the scene file.
            gain:
                Linear channel power gain factor.
                Defaults to 1.0.
            seed: Seed used to initialize the pseudo-random number generator.
        """

        # Init base class
        Channel.__init__(self, gain, seed)

        # Load the scene
        self.__scene_file = scene
        self.__scene = rt.load_scene(scene)

    @property
    def scene(self) -> rt.Scene:
        """Scene object used to generate realizations."""

        return self.__scene

    @override
    def _realize(self) -> SionnaRTChannelRealization:
        return SionnaRTChannelRealization(
            self.__scene, self.__scene_file, self.sample_hooks, self.gain
        )

    @override
    def serialize(self, process: SerializationProcess) -> None:
        Channel.serialize(self, process)
        process.serialize_string(self.__scene_file, "scene")

    @classmethod
    @override
    def Deserialize(cls, process: DeserializationProcess) -> SionnaRTChannel:
        return cls(
            process.deserialize_string("scene"),
            **Channel._DeserializeParameters(process),  # type: ignore[arg-type]
        )

    @override
    def __getstate__(self):
        base_state = Channel.__getstate__(self)
        base_state.pop("_SionnaRTChannel__scene", None)
        return base_state

    def __setstate__(self, state: dict) -> None:
        self.__scene = rt.load_scene(state["_SionnaRTChannel__scene_file"])
        for key, value in state.items():
            setattr(self, key, value)

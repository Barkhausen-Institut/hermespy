
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>modem.tools package &#8212; hermespy  documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="scenario package" href="scenario.html" />
    <link rel="prev" title="modem.coding package" href="modem.coding.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scenario.html" title="scenario package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modem.coding.html" title="modem.coding package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">hermespy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >hermespy</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modem.html" accesskey="U">modem package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modem.tools package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="modem-tools-package">
<h1>modem.tools package<a class="headerlink" href="#modem-tools-package" title="Permalink to this headline">¶</a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-modem.tools.mimo">
<span id="modem-tools-mimo-module"></span><h2>modem.tools.mimo module<a class="headerlink" href="#module-modem.tools.mimo" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="modem.tools.mimo.Mimo">
<em class="property">class </em><code class="sig-name descname">Mimo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mimo_method</span></em>, <em class="sig-param"><span class="n">number_of_streams</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">number_tx_antennas</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.mimo.Mimo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements a generic MIMO (multiple-input multiple-output) system</p>
<p>This class implements the encoder and decoder for a narrowband MIMO system.
It supports the following MIMO schemes:
- SIMO with receiver diversity, either selection combining (SC) or maximum-ratio combining (MRC)
- Transmit diversity using Alamouti’s space-time/frequency block codes scheme (STBC/SFBC) for 2 or 4 antennas
- Spatial multiplexing with zero forcing receiver (SM-ZF)
- Spatial multiplexing with zero MMSE receiver (SM-MMSE)</p>
<dl class="py attribute">
<dt id="modem.tools.mimo.Mimo.method">
<code class="sig-name descname">method</code><a class="headerlink" href="#modem.tools.mimo.Mimo.method" title="Permalink to this definition">¶</a></dt>
<dd><p>current MIMO method, can be one of the following:
‘NONE’, ‘SC’, ‘MRC’, ‘STBC’, ‘SFBC’, ‘SM-ZF’, ‘SM-MMSE’</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.mimo.Mimo.number_tx_antennas">
<code class="sig-name descname">number_tx_antennas</code><a class="headerlink" href="#modem.tools.mimo.Mimo.number_tx_antennas" title="Permalink to this definition">¶</a></dt>
<dd><p>number of transmit antennas</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.mimo.Mimo.number_of_streams">
<code class="sig-name descname">number_of_streams</code><a class="headerlink" href="#modem.tools.mimo.Mimo.number_of_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>number of spatial streams (only relevant for ‘SM’). Currently no precoding is supported
and number_tx_antennas must be equal to number_of_streams.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.mimo.Mimo.encode">
<code class="sig-name descname">encode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_data</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.mimo.Mimo.encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode data into multiple antennas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_data</strong> (<em>np.array</em>) – Input signal with K symbols.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>Encoded data with size N_tx x (K/M),</dt><dd><p>with N_tx the number of transmit antennas and M the number of spatial streams</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>output (np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.mimo.Mimo.decode">
<code class="sig-name descname">decode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_data</span></em>, <em class="sig-param"><span class="n">channel_estimation</span></em>, <em class="sig-param"><span class="n">noise_var</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.mimo.Mimo.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode data with multiple antennas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_data</strong> (<em>np.ndarray</em>) – Input signal with N_rx x K symbols, with N_rx the number of receive antennas.</p></li>
<li><p><strong>channel_estimation</strong> (<em>np.ndarray</em>) – channel estimation between every pair of antennas, of size N_rx x N_tx x K
values, with N_tx the number of transmit antennas.</p></li>
<li><p><strong>noise_var</strong> (<em>np.ndarray</em>) – Noise variance at each output symbol, with either N_rx x K values, or a scalar.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>output (np.ndarray): Decoded data with M x K symbols,</dt><dd><p>with M the number of spatial streams.</p>
</dd>
<dt>channel_estimation (np.ndarray): post-processing channel estimation,</dt><dd><p>with the same size as the output.</p>
</dd>
<dt>noise_var (np.ndarray): post-processing noise variance,</dt><dd><p>with the same size as the output.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.ndarray, np.ndarray, np.ndarray)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-modem.tools.psk_qam_mapping">
<span id="modem-tools-psk-qam-mapping-module"></span><h2>modem.tools.psk_qam_mapping module<a class="headerlink" href="#module-modem.tools.psk_qam_mapping" title="Permalink to this headline">¶</a></h2>
<p>Mapping between bits and PSK/QAM/PAM constellation</p>
<p>This module provides a class for a PSK/QAM mapper/demapper.</p>
<p>The following features are supported:
- arbitrary 2D (complex) constellation mapping can be given
- default Gray-coded constellations for BPSK, QPSK, 8-PSK, 4-, 8-, 16- PAM, 16-, 64-</p>
<blockquote>
<div><p>and 256-QAM are provided</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>all default constellations follow 3GPP standards TS 36.211</dt><dd><p>(except 8-PSK, which is not defined in 3GPP)</p>
</dd>
</dl>
</li>
<li><p>hard and soft (LLR) output are available</p></li>
</ul>
<p>This implementation has currently the following limitations:
- LLR available only for default BPSK, QPSK, 4-, 8-, 16- PAM, 16-, 64- and 256-QAM
- only linear approximation of LLR is considered, similar to the one described in:</p>
<blockquote>
<div><p>Tosato, Bisaglia, “Simplified Soft-Output Demapper for Binary Interleaved COFDM with
Application to HIPERLAN/2”, Proceedings of IEEE International Commun. Conf. (ICC) 2002</p>
</div></blockquote>
<dl class="py class">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping">
<em class="property">class </em><code class="sig-name descname">PskQamMapping</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modulation_order</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">soft_output</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">is_complex</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements the mapping of bits into complex numbers, following a PSK/QAM modulation.</p>
<dl class="py attribute">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.modulation_order">
<code class="sig-name descname">modulation_order</code><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.modulation_order" title="Permalink to this definition">¶</a></dt>
<dd><p>size of modulation constellation.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.mapping_available">
<code class="sig-name descname">mapping_available</code><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.mapping_available" title="Permalink to this definition">¶</a></dt>
<dd><p>list of available default constellations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list of int, class level</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.bits_per_symbol">
<code class="sig-name descname">bits_per_symbol</code><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.bits_per_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>number of bits in modulation symbol.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.soft_output">
<code class="sig-name descname">soft_output</code><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.soft_output" title="Permalink to this definition">¶</a></dt>
<dd><p>if True, then soft output (LLR) will be provided. #
If False, then estimated bits are returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modulation_order</strong> (<em>int</em>) – Number of points in the constellation. Must be a power of two.</p></li>
<li><p><strong>mapping</strong> (<em>numpy.ndarray</em><em>, </em><em>optional</em>) – Vector with length <cite>modulation_order</cite> defining the mapping between bits
and modulation symbols. At each symbol, bits are input MSB first.
For example, with a 32-point constellation, the bit sequence 01101
corresponds to the decimal 13,  and hence will be mapped to the
13-th element in ‘mapping’ vector.
It is optional for certain modulation orders, which are given in
PskQamMapping.mapping_available, and for which a default mapping is provided.</p></li>
<li><p><strong>soft_output</strong> (<em>bool</em>) – if True, then soft output (LLR) will be provided.
If False, then estimated bits (0 or 1) are returned.</p></li>
<li><p><strong>is_complex</strong> (<em>bool</em>) – if True, then complex modulation is considered (PSK/QAM),
if False, then real-valued modulation is considered (PAM)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="id0">
<code class="sig-name descname">mapping_available</code><em class="property"> = [2, 4, 8, 16, 64, 64, 256]</em><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.mapping_available_pam">
<code class="sig-name descname">mapping_available_pam</code><em class="property"> = [2, 4, 8, 16]</em><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.mapping_available_pam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.get_symbols">
<code class="sig-name descname">get_symbols</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bits</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.get_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the complex numbers corresponding to the information in ‘bits’.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The constellation is normalized, such that the mean symbol energy is unitary.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bits</strong> (<em>np.ndarray</em>) – Vector with N elements,
corresponding to the bits to be modulated.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Vector of N/log2(modulation_order) elements with modulated symbols.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>symbols(numpy.ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.detect_bits">
<code class="sig-name descname">detect_bits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rx_symbols</span></em>, <em class="sig-param"><span class="n">noise_variance</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.detect_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns either bits or LLR for the provided symbols.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rx_symbols</strong> (<em>np.ndarray</em>) – Vector of N received symbols, for which the bits/LLR will be estimated</p></li>
<li><p><strong>noise_variance</strong> (<em>float</em><em> or </em><em>np.ndarray</em><em>, </em><em>optional</em>) – vector with the noise variance in each received symbol. If a
scalar is given, then the same variance is assumed for all symbols.
This is only relevant if ‘self.soft_output’ is true.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Vector of N * self.bits_per_symbol elements containing either the estimated
bits or the LLR values of each bit, depending on the value of ‘self.soft_output’</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bits(np.ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.generate_pam_symbol_3gpp">
<em class="property">static </em><code class="sig-name descname">generate_pam_symbol_3gpp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modulation_order</span></em>, <em class="sig-param"><span class="n">bits</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.generate_pam_symbol_3gpp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1D amplitudes following 3GPP modulation mapping.</p>
<p>3GPP has defined in TS 36.211 mapping tables from bits into complex symbols.
Since the mapping from bits into amplitudes is the same for both I and Q components,
and this function maps blocks of N bits into one of M=2^N possible (real-valued)
amplitudes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modulation_order</strong> (<em>int</em>) – modulation order M. M=2, 4, 8, 16 are supported</p></li>
<li><p><strong>bits</strong> (<em>np.ndarray</em>) – N x K array, with K the number of symbols</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Vector of K real-valued symbols. Note that the symbols are not normalized,
and range from -(M-1) to (M+1) with step 2, e..g., for M=8,
values can be -7, -5, -3, -1, 1, 3, 5, 7.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>symbols(np.ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.get_llr_3gpp">
<em class="property">static </em><code class="sig-name descname">get_llr_3gpp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modulation_order</span></em>, <em class="sig-param"><span class="n">rx_symbols</span></em>, <em class="sig-param"><span class="n">is_complex</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.get_llr_3gpp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns LLR for each bit based on a received symbol, following 1D 3GPP modulation mapping.</p>
<p>3GPP has defined in TS 36.211 mapping tables from bits into complex symbols.
Since the mapping from bits into amplitudes is the same for both I and Q
components, and this function maps received real-valued amplitudes into
blocks of N = log2(M) log-likelihood ratios (LLR) for all bits, with M the modulation
order.</p>
<p>Only linear approximation of LLR is considered, similar to the one described in:
Tosato, Bisaglia, “Simplified Soft-Output Demapper for Binary Interleaved COFDM with
Application to HIPERLAN/2”, Proceedings of IEEE International Commun. Conf. (ICC) 2002</p>
<p>LLR calculation is available for real-valued modulations of order 2, 4, 8 or 16.</p>
<p>LLR is returned considering unit-power Gaussian noise at all symbols.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modulation_order</strong> (<em>int</em>) – modulation order M. M=2, 4, 8, 16 are supported</p></li>
<li><p><strong>rx_symbols</strong> (<em>np.ndarray</em>) – array with K received symbols</p></li>
<li><p><strong>is_complex</strong> (<em>bool</em>) – if True, then complex modulation is considered (PSK/QAM),
If False, then real-valued modulation is considered (PAM)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Vector of N x K elements with the LLR values.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>llr(np.ndarray)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="modem.tools.psk_qam_mapping.PskQamMapping.get_mapping">
<code class="sig-name descname">get_mapping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.psk_qam_mapping.PskQamMapping.get_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns current mapping table</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>array with M (modulation_order) elements containing all possible modulation symbols.
See specifications in “PskQamMapping.__init__”</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>mapping(np.ndarray)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-modem.tools.shaping_filter">
<span id="modem-tools-shaping-filter-module"></span><h2>modem.tools.shaping_filter module<a class="headerlink" href="#module-modem.tools.shaping_filter" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="modem.tools.shaping_filter.ShapingFilter">
<em class="property">class </em><code class="sig-name descname">ShapingFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filter_type</span></em>, <em class="sig-param"><span class="n">samples_per_symbol</span></em>, <em class="sig-param"><span class="n">length_in_symbols</span><span class="o">=</span><span class="default_value">16</span></em>, <em class="sig-param"><span class="n">bandwidth_factor</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">roll_off</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">is_matched</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Implements a shaping/reception filter for a communications link.</p>
<p>Currently, raised-cosine, root-raised-cosine, rectangular and FMCW
(frequency modulated continuous wave) filters are implemented.
An FIR filter with truncated impulse response is created.
The filter is normalized, i.e., the impulse response has unit energy.</p>
<dl class="py attribute">
<dt id="modem.tools.shaping_filter.ShapingFilter.samples_per_symbol">
<code class="sig-name descname">samples_per_symbol</code><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter.samples_per_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>samples per modulation symbol</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.shaping_filter.ShapingFilter.number_of_samples">
<code class="sig-name descname">number_of_samples</code><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter.number_of_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>filter length in samples</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.shaping_filter.ShapingFilter.delay_in_samples">
<code class="sig-name descname">delay_in_samples</code><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter.delay_in_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>delay introduced by filter</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt id="modem.tools.shaping_filter.ShapingFilter.impulse_response">
<code class="sig-name descname">impulse_response</code><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter.impulse_response" title="Permalink to this definition">¶</a></dt>
<dd><p>filter impulse response</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<p>Creates an object for a transmission/reception filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filter_type</strong> (<em>str</em>) – Determines filter, currently supported:
- RAISED_COSINE
- ROOT_RAISED_COSINE
- RECTANGULAR
- FMCW
- NONE</p></li>
<li><p><strong>samples_per_symbol</strong> (<em>int</em>) – number of samples per modulation symbol.</p></li>
<li><p><strong>length_in_symbols</strong> (<em>int</em>) – filter length in modulation symbols.</p></li>
<li><p><strong>bandwidth_factor</strong> (<em>float</em>) – filter bandwidth can be expanded/reduced by this factor
(default = 1), relatively to the symbol rate.
For (root)-raised cosine, the Nyquist symbol rate will be
multiplied by this factor
For rectangular pulses, the pulse width in time will be divided by this factor.
For FMCW, the sweep bandwidth will be given by the symbol rate multiplied by this
factor.</p></li>
<li><p><strong>roll_off</strong> (<em>float</em>) – Roll off factor between 0 and 1. Only relevant for (root)-raised cosine filters.</p></li>
<li><p><strong>is_matched</strong> (<em>bool</em>) – if True, then a matched filter is considered.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="modem.tools.shaping_filter.ShapingFilter.filter">
<code class="sig-name descname">filter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_signal</span></em><span class="sig-paren">)</span><a class="headerlink" href="#modem.tools.shaping_filter.ShapingFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filters the input signal with the shaping filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_signal</strong> (<em>np.array</em>) – Input signal with N samples to filter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Filtered signal with  <cite>N + samples_per_symbol*length_in_symbols - 1</cite> samples.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-modem.tools">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-modem.tools" title="Permalink to this headline">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">modem.tools package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-modem.tools.mimo">modem.tools.mimo module</a></li>
<li><a class="reference internal" href="#module-modem.tools.psk_qam_mapping">modem.tools.psk_qam_mapping module</a></li>
<li><a class="reference internal" href="#module-modem.tools.shaping_filter">modem.tools.shaping_filter module</a></li>
<li><a class="reference internal" href="#module-modem.tools">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modem.coding.html"
                        title="previous chapter">modem.coding package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="scenario.html"
                        title="next chapter">scenario package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modem.tools.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="scenario.html" title="scenario package"
             >next</a> |</li>
        <li class="right" >
          <a href="modem.coding.html" title="modem.coding package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">hermespy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >hermespy</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="modem.html" >modem package</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">modem.tools package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, Barkhausen Institut.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.0.
    </div>
  </body>
</html>
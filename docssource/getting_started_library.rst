========
Library
========

.. |br| raw:: html

     <br>

This section outlines how to include HermesPy into your own Python projects and provides
basic reference examples to get new users accustomed to the API.

In its core, the HermesPy API aims to abstract the process of wireless communication signal processing
in an object-oriented class structure.
Each processing step is represented by a dedicated class and can be adapted and customized
by the library user.
Considering a single link between a receiving and transmitting modem,
the software architecture is outlined in the following flowchart:

.. mermaid::

   %%{init: {'theme': 'dark'}}%%
   flowchart TD

      subgraph TX[Transmitter]
            direction LR

            BSTX(BitSource) --> BCTX(Bit-Encoding) --> MAPTX

            subgraph WRX[WaveformGenerator]
                direction LR
                MAPTX(Mapping) --> PRETX(Precoding) --> MODTX(Modulation)
            end


            MODTX --> RFTX(RF-Chain)
      end

      TX --> F[Channel] --> RX

      subgraph RX[Receiver]
            direction RL

            RFRX(RF-Chain) --> SRX(Synchronization)

            subgraph WTX[WaveformGenerator]
                direction RL
                SRX --> MODRX(De-Modulation) --> PRERX(Precoding) --> MAPRX(Un-Mapping)
            end

            MAPRX --> BCRX(Bit-Decoding)

      end

Each HermesPy :doc:`Scenario </api/hermespy.scenario.scenario>` consists of multiple links
between :doc:`Transmitters </api/hermespy.modem.transmitter>`
and :doc:`Receivers </api/hermespy.modem.receiver>`, which are both :doc:`Modems </api/hermespy.modem.modem>`.
Transmitters feed :doc:`Signal</api/hermespy.signal.signal>` models of electromagnetic waves
into a wireless transmission :doc:`Channel </api/hermespy.channel.channel>`.
After propagation over said channel, receivers subsequently pick up the distorted signals.

Both transmitters and receivers perform a sequence of processing steps in order to
exchange information represented by binary bit-streams:

#. :doc:`BitsSource</api/hermespy.source.bits_source>` *(transmitters only)* |br|
   Generate a sequence of bits to be transmitted.

#. :doc:`Bit-Encoding</api/hermespy.coding.encoder_manager>` |br|
   Perform operations on the bit-sequence to add redundancy and correct errors.

#. :doc:`Waveform-Generation </api/hermespy.modem.waveform_generator>` |br|
   Map bits to communication symbols, modulate the symbols to electromagnetic baseband-signals.

#. :doc:`Radio-Frequency Chain </api/hermespy.modem.rf_chain>` |br|
   Mix and amplify the baseband-signals to radio-frequency-band signals.

Note that receivers perform the inverse processing steps in reverse order.

***************
Getting Started
***************

Assuming HermesPy is properly installed within the currently selected Python environment,
users may define custom scenarios to be investigated.

This chapter provides several examples outlining the utilization of HermesPy as a library.

Transmissions
-------------

The following code generates the samples of a single communication frame
transmitted by a PSK/QAM modem:

.. code-block:: python
   :linenos:

   import matplotlib.pyplot as plt
   from hermespy import Scenario, Transmitter
   from hermespy.modem import WaveformGeneratorPskQam

   transmitter = Transmitter()
   transmitter.waveform_generator = WaveformGeneratorPskQam()

   scenario = Scenario()
   scenario.add_transmitter(transmitter)

   signal, _ = transmitter.send()
   signal.plot()
   plt.show()

Within this snippet, multiple statements lead to the generation and simulation of a single communication frame signal.

* Initially, the required Python modules are imported *(lines 1-3)*.
* A new transmitter modem handle is created *(line 5)*.
* The waveform to be generated by the transmitter is configured by assigning a specific
  :doc:`Waveform Generator </api/hermespy.modem.waveform_generator>` instance to the transmitter's
  waveform_generator property *(line 6)*. |br|
  In our case, this is an instance of a :doc:`PKS/QAM </api/hermespy.modem.waveform_generator_psk_qam>`
  waveform generator.
* The transmitter is inserted into an empty simulation scenario *(lines 8-9)*
* An electromagnetic waveform, encoding a single communication frame, emitted by the transmitter
  is generated and plotted *(lines 11-13)*

Executing the snippet will result in a plot similar to

.. image:: images/getting_started_signal_plot.png
  :alt: PSK/QAM default waveform plot

which visualizes the generated samples in time-domain (left sub-plot) and its respective
discrete fourier transform (right sub-plot).

While this is only a minimal example, it highlights the philosophy behind the HermesPy API, namely that
each signal processing step is represented by a class modeling its functionality.
Instances of those classes are assigned to property slots, where they will be executed sequentially
during signal simulation.
Changing the waveform generated by the transmitter defined in the previous snippet
is therefore as simple as assigning a different type of
:doc:`Waveform Generator </api/hermespy.modem.waveform_generator>`
to its waveform_generator property slot.

Of course, a multitude of parameters can be configured to customize the behaviour of each processing step.
For instance, the frame generated by a :doc:`PKS/QAM </api/hermespy.modem.waveform_generator_psk_qam>` waveform
generator features a preamble of multiple reference symbols at the beginning of the communication frame.
They may be removed by specifying the respective property

.. code-block:: python

   transmitter.waveform_generator.num_preamble_symbols = 0

configuring the number of preamble symbols, resulting in a signal waveform similar to

.. image:: images/getting_started_signal_plot_no_preamble.png
  :alt: PSK/QAM waveform plot without preamble

in which the preamble has clearly been removed.
Describing all configurable parameters is beyond the scope of this introduction,
the API documentation of each processing step should be consulted for detailed descriptions.

A full communication link over an ideal channel between a single transmitter and receiver modem is established
by adding receiver to the scenario:

.. code-block:: python
   :linenos:

   from hermespy import Scenario, Transmitter, Receiver
   from hermespy.modem import WaveformGeneratorPskQam

   transmitter = Transmitter()
   transmitter.waveform_generator = WaveformGeneratorPskQam()

   receiver = Receiver()
   receiver.waveform_generator = WaveformGeneratorPskQam()

   scenario = Scenario()
   scenario.add_transmitter(transmitter)
   scenario.add_receiver(receiver)

   transmitted_signal, _ = transmitter.send()
   propagated_signal, channel_state = scenario.channel(transmitter, receiver).propagate(transmitted_signal)

   received_signal = receiver.receive(propagated_signal)
   received_bits, received_symbols = receiver.demodulate(propagated_signal, channel_state)

The relevant sections in lines *14-15* highlight how a signal transmission over the channel between
two modems is simulated by selecting the respective channel and propagating a waveform over it.
As a result, a tuple of the waveform after propagation and its respective channel state information is returned.
In lines *17-18* the propagated signal is down-mixed by the receiver's radio-frequency chain and demodulated
into symbols, and subsequently mapped to bits.

Simulations
-----------

Evaluating multiple transmissions in scenarios featuring several modems can become quite tedious,
which is why HermesPy offers the :doc:`Simulation </api/hermespy.simulator_core.simulation>` helper class.
Considering the same scenario as before, the following snippet demonstrates how
a single communication drop at 40dB signal-to-noise ratio can be generated:

.. code-block:: python
   :linenos:

   import matplotlib.pyplot as plt
   from hermespy import Scenario, Transmitter, Receiver, Simulation
   from hermespy.modem import WaveformGeneratorPskQam

   transmitter = Transmitter()
   transmitter.waveform_generator = WaveformGeneratorPskQam()

   receiver = Receiver()
   receiver.waveform_generator = WaveformGeneratorPskQam()

   scenario = Scenario()
   scenario.add_transmitter(transmitter)
   scenario.add_receiver(receiver)

   simulation = Simulation()
   simulation.add_scenario(scenario)

   drop = simulation.drop(40.)
   drop.plot_received_symbols()
   drop.plot_bit_errors()

   plt.show()

Note that lines *5-16* are identical to the previous snippet, defining a scenario with a single receiver
and transmitter modem emitting :doc:`PKS/QAM </api/hermespy.modem.waveform_generator_psk_qam>` waveforms.
However, the scenario is now being managed by the :doc:`Simulation </api/hermespy.simulator_core.simulation>` helper.
It generates and visualizes a single information exchange between all scenario modems *(lines 18)*.
In HermesPy, this is referred to as a :doc:`Drop </api/hermespy.simulator_core.drop>`.
Visualizing the received symbols *(line 19)* and bit errors *(line 20)* during transmission
results in the following constellation and bit error plots:

.. list-table::

    * - .. figure:: /images/getting_started_constellation_low_noise.png

           Symbol Constellation, Low Noise

      - .. figure:: /images/getting_started_errors_low_noise.png

           Bit Errors, Low Noise

Of course, due to the high signal-to-noise ratio and the ideal channel model, no bit errors occur during transmission.
Generating another drop at a much lower ratio, namely 5dB,

.. code-block:: python

   drop = simulation.drop(5.)

leads to several bit-errors during data transmission:

.. list-table::

    * - .. figure:: /images/getting_started_constellation_high_noise.png

           Symbol Constellation, High Noise

      - .. figure:: /images/getting_started_errors_high_noise.png

           Bit Errors, High Noise
